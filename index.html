<!DOCTYPE html>
<html lang="en" class="light">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Macro Dashboard</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://saga-labs.github.io/macro-crypto-dashboard/">
    <meta property="og:title" content="Crypto Macro Dashboard">
    <meta property="og:description" content="Professional trading dashboard combining Bitcoin price action with key macroeconomic indicators for informed crypto investment decisions.">
    <meta property="og:image" content="https://saga-labs.github.io/macro-crypto-dashboard/images/macro-dashboard.png">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://saga-labs.github.io/macro-crypto-dashboard/">
    <meta property="twitter:title" content="Crypto Macro Dashboard">
    <meta property="twitter:description" content="Professional trading dashboard combining Bitcoin price action with key macroeconomic indicators for informed crypto investment decisions.">
    <meta property="twitter:image" content="https://saga-labs.github.io/macro-crypto-dashboard/images/macro-dashboard.png">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
        }
    </script>
</head>

<body class="min-h-screen bg-slate-50 dark:bg-slate-900 p-6 transition-colors duration-300">
    <header class="max-w-6xl mx-auto mb-8">
        <div class="flex justify-between items-start mb-4">
            <div>
                <h1 class="text-3xl md:text-4xl font-semibold mb-2 text-slate-900 dark:text-white">Crypto Macro
                    Dashboard</h1>
                <p class="text-slate-600 dark:text-slate-300">Live charts combining crypto markets with key
                    macroeconomic indicators.</p>
            </div>

            <!-- Settings Panel -->
            <div class="flex gap-2">
                <a href="https://github.com/Saga-Labs/macro-crypto-dashboard" target="_blank" rel="noopener noreferrer"
                    class="p-2 bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-lg hover:bg-slate-50 dark:hover:bg-slate-700 transition-colors"
                    title="View on GitHub">
                    <svg class="w-5 h-5 text-slate-600 dark:text-slate-300" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                    </svg>
                </a>
                <button id="settingsBtn"
                    class="p-2 bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-lg hover:bg-slate-50 dark:hover:bg-slate-700 transition-colors">
                    <svg class="w-5 h-5 text-slate-600 dark:text-slate-300" fill="none" stroke="currentColor"
                        viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z">
                        </path>
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                    </svg>
                </button>
                <button id="darkModeToggle"
                    class="p-2 bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-lg hover:bg-slate-50 dark:hover:bg-slate-700 transition-colors">
                    <svg id="sunIcon" class="w-5 h-5 text-slate-600 dark:text-slate-300 hidden dark:block" fill="none"
                        stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z">
                        </path>
                    </svg>
                    <svg id="moonIcon" class="w-5 h-5 text-slate-600 dark:text-slate-300 block dark:hidden" fill="none"
                        stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z">
                        </path>
                    </svg>
                </button>
            </div>
        </div>

        <!-- Settings Panel -->
        <div id="settingsPanel"
            class="hidden mb-6 p-4 bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-lg">
            <h3 class="text-lg font-medium mb-4 text-slate-900 dark:text-white">Chart Settings</h3>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div>
                    <label class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-2">Data Points</label>
                    <select id="dataPoints"
                        class="w-full p-2 border border-slate-300 dark:border-slate-600 rounded-md bg-white dark:bg-slate-700 text-slate-900 dark:text-white">
                        <option value="30">Last 30 points</option>
                        <option value="60">Last 60 points</option>
                        <option value="90" selected>Last 90 points (3 months)</option>
                        <option value="180">Last 180 points (6 months)</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-2">Chart Type</label>
                    <select id="chartType"
                        class="w-full p-2 border border-slate-300 dark:border-slate-600 rounded-md bg-white dark:bg-slate-700 text-slate-900 dark:text-white">
                        <option value="line" selected>Line Chart</option>
                        <option value="bar">Bar Chart</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-2">Show Fill</label>
                    <select id="showFill"
                        class="w-full p-2 border border-slate-300 dark:border-slate-600 rounded-md bg-white dark:bg-slate-700 text-slate-900 dark:text-white">
                        <option value="false" selected>No Fill</option>
                        <option value="true">Fill Area</option>
                    </select>
                </div>
            </div>
            <div class="mt-4 flex gap-2">
                <button id="applySettings"
                    class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors">Apply
                    Settings</button>
                <button id="refreshData"
                    class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors">Refresh
                    Data</button>
            </div>
        </div>

        <div id="status"
            class="mt-4 p-3 bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg hidden">
            <p class="text-blue-700 dark:text-blue-300">Loading economic data...</p>
        </div>
    </header>

    <main class="max-w-6xl mx-auto space-y-6">
        <!-- Row 1: Bitcoin Price + Global M2 vs Bitcoin YoY + Inverted DXY vs Bitcoin 3M -->
        <div class="grid gap-4 grid-cols-1 md:grid-cols-2 xl:grid-cols-3">
            <!-- Bitcoin Price Chart -->
            <section class="bg-white dark:bg-slate-800 rounded-2xl shadow p-3">
                <h2 class="text-base font-medium mb-2 text-slate-900 dark:text-white">Bitcoin Price (USD)</h2>
                <div class="h-48 mb-2">
                    <canvas id="bitcoinChart"></canvas>
                </div>
                <div class="text-xs text-slate-600 dark:text-slate-300 space-y-1">
                    <p><strong>Key insight:</strong> Bitcoin drives market sentiment and predicts altcoin trends within 24-48 hours.</p>
                </div>
            </section>

            <!-- Global M2 vs Bitcoin YoY -->
            <section class="bg-white dark:bg-slate-800 rounded-2xl shadow p-3">
                <h2 class="text-base font-medium mb-2 text-slate-900 dark:text-white">M2 vs Bitcoin YoY</h2>
                <div class="h-48 mb-2">
                    <canvas id="m2BitcoinChart"></canvas>
                </div>
                <div class="text-xs text-slate-600 dark:text-slate-300 space-y-1">
                    <p><strong>Key insight:</strong> M2 growth >10% YoY often drives Bitcoin adoption as inflation hedge.</p>
                </div>
            </section>
        </div>

            <!-- Inverted DXY vs Bitcoin 3m Change -->
            <section class="bg-white dark:bg-slate-800 rounded-2xl shadow p-3">
                <h2 class="text-base font-medium mb-2 text-slate-900 dark:text-white">DXY vs Bitcoin 3M</h2>
                <div class="h-48 mb-2">
                    <canvas id="dxyBitcoinChart"></canvas>
                </div>
                <div class="text-xs text-slate-600 dark:text-slate-300 space-y-1">
                    <p><strong>Key insight:</strong> Dollar weakness precedes Bitcoin rallies by ~3 months. Leading indicator for timing.</p>
                </div>
            </section>
        </div>

        <!-- Row 2: Industrial Production + NFCI + M2 -->
        <div class="grid gap-4 grid-cols-1 md:grid-cols-2 xl:grid-cols-3">
            <!-- Industrial Production -->
            <section class="bg-white dark:bg-slate-800 rounded-2xl shadow p-3">
                <h2 class="text-base font-medium mb-2 text-slate-900 dark:text-white">Industrial Production</h2>
                <div class="h-48 mb-2">
                    <canvas id="pmiChart"></canvas>
                </div>
                <div class="text-xs text-slate-600 dark:text-slate-300 space-y-1">
                    <p><strong>Key insight:</strong> Rising production supports risk assets. Declining production triggers rotation away from crypto.</p>
                </div>
            </section>
            <!-- NFCI -->
            <section class="bg-white dark:bg-slate-800 rounded-2xl shadow p-3">
                <h2 class="text-base font-medium mb-2 text-slate-900 dark:text-white">Financial Conditions</h2>
                <div class="h-48 mb-2">
                    <canvas id="nfciChart"></canvas>
                </div>
                <div class="text-xs text-slate-600 dark:text-slate-300 space-y-1">
                    <p><strong>Key insight:</strong> Loose conditions (NFCI < -0.5) fuel crypto bulls. Tight conditions (>0.5) precede bears.</p>
                </div>
            </section>

            <!-- M2 -->
            <section class="bg-white dark:bg-slate-800 rounded-2xl shadow p-3">
                <h2 class="text-base font-medium mb-2 text-slate-900 dark:text-white">M2 Money Supply</h2>
                <div class="h-48 mb-2">
                    <canvas id="m2Chart"></canvas>
                </div>
                <div class="text-xs text-slate-600 dark:text-slate-300 space-y-1">
                    <p><strong>Key insight:</strong> Rapid M2 growth drives crypto adoption. Contractions hurt crypto as liquidity dries up.</p>
                </div>
            </section>
        </div>

        <!-- Row 3: TGA (single chart in last row) -->
        <div class="grid gap-4 grid-cols-1 md:grid-cols-2 xl:grid-cols-3">
            <!-- TGA -->
            <section class="bg-white dark:bg-slate-800 rounded-2xl shadow p-3">
                <h2 class="text-base font-medium mb-2 text-slate-900 dark:text-white">Treasury Account</h2>
                <div class="h-48 mb-2">
                    <canvas id="tgaChart"></canvas>
                </div>
                <div class="text-xs text-slate-600 dark:text-slate-300 space-y-1">
                    <p><strong>Key insight:</strong> TGA drawdowns inject liquidity, boosting crypto. Builds drain liquidity, pressuring prices.</p>
                </div>
            </section>
        </div>
    </main>

    <footer class="max-w-6xl mx-auto mt-8 text-sm text-slate-500 dark:text-slate-400">
        <div>Professional trading dashboard powered by live market data from CoinGecko, Binance & FRED APIs.</div>
    </footer>

    <script>
        const FRED_API_KEY = "beee1466f76464d05ca4d42d26e0302c";
        let chartInstances = {};
        let chartData = {};
        let retryCount = {}; // Track retry attempts per chart
        let settings = {
            dataPoints: 90, // 3 months of data (approximately)
            chartType: 'line',
            showFill: false
        };

        // Dark mode functionality
        function initDarkMode() {
            const darkModeToggle = document.getElementById('darkModeToggle');
            const html = document.documentElement;

            // Check for saved theme preference or default to light
            const savedTheme = localStorage.getItem('theme') || 'light';
            html.classList.toggle('dark', savedTheme === 'dark');

            darkModeToggle.addEventListener('click', () => {
                const isDark = html.classList.toggle('dark');
                localStorage.setItem('theme', isDark ? 'dark' : 'light');
                updateTradingViewTheme();
                updateChartThemes();
            });
        }

        function updateTradingViewTheme() {
            const isDark = document.documentElement.classList.contains('dark');
            const theme = isDark ? 'Dark' : 'Light';
            const toolbarbg = isDark ? '1e293b' : 'F1F3F6';

            // Update TradingView iframes
            const iframes = document.querySelectorAll('iframe');
            iframes.forEach(iframe => {
                const src = iframe.src;
                const newSrc = src.replace(/theme=(Light|Dark)/, `theme=${theme}`)
                    .replace(/toolbarbg=[A-Fa-f0-9]{6}/, `toolbarbg=${toolbarbg}`);
                if (newSrc !== src) {
                    iframe.src = newSrc;
                }
            });
        }

        function updateChartThemes() {
            const isDark = document.documentElement.classList.contains('dark');
            Object.keys(chartInstances).forEach(chartId => {
                if (chartInstances[chartId]) {
                    chartInstances[chartId].options.scales.x.grid = {
                        color: isDark ? '#374151' : '#f0f0f0'
                    };
                    chartInstances[chartId].options.scales.y.grid = {
                        color: isDark ? '#374151' : '#f0f0f0'
                    };
                    chartInstances[chartId].options.scales.x.ticks = {
                        color: isDark ? '#9ca3af' : '#6b7280'
                    };
                    chartInstances[chartId].options.scales.y.ticks = {
                        color: isDark ? '#9ca3af' : '#6b7280'
                    };
                    chartInstances[chartId].update();
                }
            });
        }

        // Settings functionality
        function initSettings() {
            const settingsBtn = document.getElementById('settingsBtn');
            const settingsPanel = document.getElementById('settingsPanel');
            const applySettings = document.getElementById('applySettings');
            const refreshData = document.getElementById('refreshData');

            settingsBtn.addEventListener('click', () => {
                settingsPanel.classList.toggle('hidden');
            });

            applySettings.addEventListener('click', () => {
                settings.dataPoints = parseInt(document.getElementById('dataPoints').value);
                settings.chartType = document.getElementById('chartType').value;
                settings.showFill = document.getElementById('showFill').value === 'true';

                // Recreate charts with new settings
                recreateCharts();
                settingsPanel.classList.add('hidden');
            });

            refreshData.addEventListener('click', () => {
                loadData();
                settingsPanel.classList.add('hidden');
            });
        }

        async function fetchFRED(seriesId) {
            console.log(`üîç Fetching FRED series: ${seriesId}`);
            
            // Try multiple approaches for FRED data with better error handling
            const approaches = [
                // Approach 1: AllOrigins (most reliable)
                async () => {
                    const proxyUrl = 'https://api.allorigins.win/get?url=';
                    const fredUrl = `https://api.stlouisfed.org/fred/series/observations?series_id=${seriesId}&api_key=${FRED_API_KEY}&file_type=json&limit=300&sort_order=desc`;
                    console.log(`üì° Trying AllOrigins for ${seriesId}...`);
                    
                    const response = await fetch(proxyUrl + encodeURIComponent(fredUrl), {
                        method: 'GET',
                        headers: { 'Accept': 'application/json' }
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const proxyData = await response.json();
                    if (!proxyData.contents) {
                        throw new Error('No contents in proxy response');
                    }
                    
                    const data = JSON.parse(proxyData.contents);
                    console.log(`üìä AllOrigins response for ${seriesId}:`, data.observations?.length || 0, 'observations');
                    return data;
                },
                
                // Approach 2: CORS Proxy
                async () => {
                    const proxyUrl = 'https://corsproxy.io/?';
                    const fredUrl = `https://api.stlouisfed.org/fred/series/observations?series_id=${seriesId}&api_key=${FRED_API_KEY}&file_type=json&limit=300&sort_order=desc`;
                    console.log(`üì° Trying CORS Proxy for ${seriesId}...`);
                    
                    const response = await fetch(proxyUrl + encodeURIComponent(fredUrl), {
                        method: 'GET',
                        headers: { 'Accept': 'application/json' }
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    console.log(`üìä CORS Proxy response for ${seriesId}:`, data.observations?.length || 0, 'observations');
                    return data;
                },
                
                // Approach 3: Try without proxy (might work in some environments)
                async () => {
                    const fredUrl = `https://api.stlouisfed.org/fred/series/observations?series_id=${seriesId}&api_key=${FRED_API_KEY}&file_type=json&limit=300&sort_order=desc`;
                    console.log(`üì° Trying direct FRED API for ${seriesId}...`);
                    
                    const response = await fetch(fredUrl, {
                        method: 'GET',
                        headers: { 'Accept': 'application/json' }
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    console.log(`üìä Direct API response for ${seriesId}:`, data.observations?.length || 0, 'observations');
                    return data;
                }
            ];

            let lastError = null;
            
            for (let i = 0; i < approaches.length; i++) {
                try {
                    const data = await approaches[i]();
                    
                    if (!data || !data.observations || !Array.isArray(data.observations)) {
                        throw new Error(`Invalid data structure: ${JSON.stringify(data).substring(0, 100)}...`);
                    }

                    console.log(`üìà Processing ${data.observations.length} observations for ${seriesId}`);
                    
                    const validData = data.observations
                        .filter(o => {
                            const isValid = o.value !== "." && o.value !== null && o.value !== undefined && !isNaN(parseFloat(o.value));
                            if (!isValid) console.log(`‚ùå Invalid observation:`, o);
                            return isValid;
                        })
                        .reverse() // Chronological order
                        .slice(-Math.max(settings.dataPoints, 120))
                        .map(o => ({
                            date: o.date,
                            value: parseFloat(o.value)
                        }));

                    if (validData.length === 0) {
                        throw new Error(`No valid data points found in ${data.observations.length} observations`);
                    }

                    console.log(`‚úÖ Successfully processed ${seriesId}: ${validData.length} valid data points`);
                    console.log(`üìÖ Date range: ${validData[0].date} to ${validData[validData.length - 1].date}`);
                    console.log(`üìä Value range: ${Math.min(...validData.map(d => d.value)).toFixed(2)} to ${Math.max(...validData.map(d => d.value)).toFixed(2)}`);
                    
                    return validData;

                } catch (error) {
                    lastError = error;
                    console.error(`‚ùå Approach ${i + 1} failed for ${seriesId}:`, error.message);
                    
                    if (i < approaches.length - 1) {
                        console.log(`üîÑ Trying next approach for ${seriesId}...`);
                    }
                }
            }
            
            console.error(`üí• All approaches failed for ${seriesId}. Last error:`, lastError?.message);
            throw new Error(`All approaches failed for ${seriesId}: ${lastError?.message}`);
        }

        async function fetchBitcoinPrice() {
            const apis = [
                {
                    name: 'CoinGecko',
                    fetch: async () => {
                        const response = await fetch('https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=usd&days=180&interval=daily');
                        const data = await response.json();
                        return data.prices.map(([timestamp, price]) => ({
                            date: new Date(timestamp).toISOString().split('T')[0],
                            value: price
                        }));
                    }
                },
                {
                    name: 'CoinCap',
                    fetch: async () => {
                        const response = await fetch('https://api.coincap.io/v2/assets/bitcoin/history?interval=d1&start=' + (Date.now() - 180 * 24 * 60 * 60 * 1000));
                        const data = await response.json();
                        return data.data.map(item => ({
                            date: new Date(item.time).toISOString().split('T')[0],
                            value: parseFloat(item.priceUsd)
                        }));
                    }
                },
                {
                    name: 'Binance',
                    fetch: async () => {
                        const response = await fetch('https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1d&limit=180');
                        const data = await response.json();
                        return data.map(item => ({
                            date: new Date(item[0]).toISOString().split('T')[0],
                            value: parseFloat(item[4]) // Close price
                        }));
                    }
                }
            ];

            for (const api of apis) {
                try {
                    console.log(`Fetching Bitcoin from ${api.name}...`);
                    const data = await api.fetch();
                    
                    if (!data || data.length === 0) {
                        throw new Error('No data received');
                    }

                    const sortedData = data
                        .sort((a, b) => new Date(a.date) - new Date(b.date))
                        .slice(-Math.max(settings.dataPoints, 120));

                    console.log(`‚úÖ Successfully fetched Bitcoin from ${api.name}: ${sortedData.length} data points`);
                    return sortedData;

                } catch (error) {
                    console.log(`‚ùå ${api.name} failed:`, error.message);
                }
            }
            
            throw new Error('All Bitcoin APIs failed');
        }

        function calculateYoYChange(data) {
            const result = [];
            for (let i = 12; i < data.length; i++) {
                const current = data[i].value;
                const yearAgo = data[i - 12].value;
                const yoyChange = ((current - yearAgo) / yearAgo) * 100;
                result.push({
                    date: data[i].date,
                    value: yoyChange
                });
            }
            return result;
        }

        function calculate3MChange(data) {
            const result = [];
            for (let i = 3; i < data.length; i++) {
                const current = data[i].value;
                const threeMonthsAgo = data[i - 3].value;
                const change = ((current - threeMonthsAgo) / threeMonthsAgo) * 100;
                result.push({
                    date: data[i].date,
                    value: change
                });
            }
            return result;
        }

        function invertAndAdvance(data, months = 3) {
            const result = [];
            for (let i = 0; i < data.length - months; i++) {
                result.push({
                    date: data[i + months].date,
                    value: -data[i].value // Invert the values
                });
            }
            return result;
        }

        // Loading animation for individual charts
        function showChartLoading(chartId) {
            const canvas = document.getElementById(chartId);
            if (!canvas) return;
            
            const container = canvas.parentElement;
            const isDark = document.documentElement.classList.contains('dark');
            
            container.innerHTML = `
                <div class="h-full flex items-center justify-center ${isDark ? 'bg-slate-700' : 'bg-slate-100'} rounded-lg">
                    <div class="text-center">
                        <div class="animate-spin rounded-full h-8 w-8 border-b-2 ${isDark ? 'border-blue-400' : 'border-blue-600'} mx-auto mb-2"></div>
                        <div class="${isDark ? 'text-slate-300' : 'text-slate-600'} text-sm">Loading data...</div>
                    </div>
                </div>
            `;
        }

        function showDataError(chartId, errorMessage, retryCount = 0) {
            const canvas = document.getElementById(chartId);
            if (!canvas) return;
            
            const container = canvas.parentElement;
            const isDark = document.documentElement.classList.contains('dark');
            
            // Only show error after 3 failed attempts
            if (retryCount < 3) {
                return;
            }
            
            // Replace canvas with error message
            container.innerHTML = `
                <div class="h-full flex items-center justify-center ${isDark ? 'bg-red-900/20 border-red-800' : 'bg-red-50 border-red-200'} border-2 rounded-lg">
                    <div class="text-center p-4">
                        <div class="${isDark ? 'text-red-400' : 'text-red-600'} text-lg font-medium mb-2">‚ùå Data Unavailable</div>
                        <div class="${isDark ? 'text-red-300' : 'text-red-500'} text-sm mb-3">${errorMessage}</div>
                        <div class="space-y-2">
                            <button onclick="retryChart('${chartId}')" class="block w-full px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors text-sm">
                                üîÑ Retry Chart
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }

        // Add a global retry function
        window.retryData = function() {
            console.log('üîÑ Manual retry triggered');
            loadData();
        }

        // Retry individual chart
        window.retryChart = async function(chartId) {
            console.log(`üîÑ Retrying chart: ${chartId}`);
            showChartLoading(chartId);
            
            // Reset retry count for this chart
            retryCount[chartId] = 0;
            
            try {
                if (chartId === 'bitcoinChart') {
                    await loadBitcoinData();
                } else {
                    await loadEconomicData(chartId);
                }
            } catch (error) {
                console.error(`Failed to retry ${chartId}:`, error);
                showDataError(chartId, error.message, 3);
            }
        }

        // Load data for specific chart with retry logic
        async function loadDataWithRetry(chartId, dataLoader, maxRetries = 3) {
            if (!retryCount[chartId]) retryCount[chartId] = 0;
            
            showChartLoading(chartId);
            
            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    retryCount[chartId] = attempt;
                    const data = await dataLoader();
                    
                    if (data && data.length > 0) {
                        return data;
                    } else {
                        throw new Error('No data received');
                    }
                } catch (error) {
                    console.log(`‚ùå Attempt ${attempt + 1}/${maxRetries} failed for ${chartId}:`, error.message);
                    
                    if (attempt < maxRetries - 1) {
                        // Wait before retry (exponential backoff)
                        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
                    } else {
                        // Final attempt failed
                        retryCount[chartId] = maxRetries;
                        showDataError(chartId, error.message, maxRetries);
                        throw error;
                    }
                }
            }
        }

        // Add global test function
        window.testAPIs = testAPIs;

        function createChart(canvasId, data, label, color) {
            // Restore canvas element if it was replaced by loading/error state
            const container = document.getElementById(canvasId)?.parentElement;
            if (container && !document.getElementById(canvasId)) {
                container.innerHTML = `<canvas id="${canvasId}"></canvas>`;
            }
            
            const canvas = document.getElementById(canvasId);
            if (!canvas) {
                console.error(`Canvas ${canvasId} not found`);
                return;
            }
            
            const ctx = canvas.getContext('2d');
            const isDark = document.documentElement.classList.contains('dark');

            // Destroy existing chart if it exists
            if (chartInstances[canvasId]) {
                chartInstances[canvasId].destroy();
            }

            chartInstances[canvasId] = new Chart(ctx, {
                type: settings.chartType,
                data: {
                    labels: data.map(d => d.date),
                    datasets: [{
                        label: label,
                        data: data.map(d => d.value),
                        borderColor: color,
                        backgroundColor: settings.showFill ? color + '20' : 'transparent',
                        borderWidth: 2,
                        fill: settings.showFill,
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            display: false,
                            grid: {
                                color: isDark ? '#374151' : '#f0f0f0'
                            },
                            ticks: {
                                color: isDark ? '#9ca3af' : '#6b7280'
                            }
                        },
                        y: {
                            beginAtZero: false,
                            grid: {
                                color: isDark ? '#374151' : '#f0f0f0'
                            },
                            ticks: {
                                color: isDark ? '#9ca3af' : '#6b7280'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                }
            });

            // Add sentiment indicator
            addSentimentIndicator(canvasId, data, label);
        }

        function addSentimentIndicator(canvasId, data, label) {
            const canvas = document.getElementById(canvasId);
            if (!canvas || !data || data.length === 0) return;

            const container = canvas.parentElement.parentElement; // Get the section element
            let sentimentEl = container.querySelector('.sentiment-indicator');
            
            if (!sentimentEl) {
                sentimentEl = document.createElement('div');
                sentimentEl.className = 'sentiment-indicator mt-3 flex items-center justify-center space-x-2 p-2 rounded-lg';
                container.appendChild(sentimentEl);
            }

            const latestValue = data[data.length - 1].value;
            const sentiment = getCryptoSentiment(label, latestValue, data);
            
            const colors = {
                good: 'bg-green-100 dark:bg-green-900/20 border border-green-200 dark:border-green-800',
                neutral: 'bg-yellow-100 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800',
                bad: 'bg-red-100 dark:bg-red-900/20 border border-red-200 dark:border-red-800'
            };

            const textColors = {
                good: 'text-green-700 dark:text-green-300',
                neutral: 'text-yellow-700 dark:text-yellow-300',
                bad: 'text-red-700 dark:text-red-300'
            };

            const lights = {
                good: 'üü¢',
                neutral: 'üü°',
                bad: 'üî¥'
            };

            sentimentEl.className = `sentiment-indicator mt-3 flex items-center justify-center space-x-2 p-2 rounded-lg ${colors[sentiment.status]}`;
            sentimentEl.innerHTML = `
                <span class="text-lg">${lights[sentiment.status]}</span>
                <span class="font-medium ${textColors[sentiment.status]}">${sentiment.status.toUpperCase()}</span>
                <span class="text-sm ${textColors[sentiment.status]}">${sentiment.reason}</span>
            `;
        }

        function getCryptoSentiment(label, latestValue, data) {
            // Get trend (comparing last 10 vs previous 10 data points)
            const recent = data.slice(-10);
            const previous = data.slice(-20, -10);
            const recentAvg = recent.reduce((sum, d) => sum + d.value, 0) / recent.length;
            const previousAvg = previous.reduce((sum, d) => sum + d.value, 0) / previous.length;
            const trend = recentAvg > previousAvg ? 'rising' : 'falling';

            switch (label) {
                case 'Bitcoin Price':
                    if (trend === 'rising') return { status: 'good', reason: 'Price trending up' };
                    if (trend === 'falling') return { status: 'bad', reason: 'Price trending down' };
                    return { status: 'neutral', reason: 'Price stable' };

                case 'PMI':
                    if (latestValue > 52) return { status: 'good', reason: 'Strong expansion' };
                    if (latestValue < 48) return { status: 'bad', reason: 'Contraction risk' };
                    return { status: 'neutral', reason: 'Moderate conditions' };

                case 'NFCI':
                    if (latestValue < -0.5) return { status: 'good', reason: 'Loose conditions' };
                    if (latestValue > 0.5) return { status: 'bad', reason: 'Tight conditions' };
                    return { status: 'neutral', reason: 'Normal conditions' };

                case 'M2':
                    if (trend === 'rising') return { status: 'good', reason: 'Liquidity increasing' };
                    if (trend === 'falling') return { status: 'bad', reason: 'Liquidity decreasing' };
                    return { status: 'neutral', reason: 'Stable liquidity' };

                case 'TGA':
                    if (trend === 'falling') return { status: 'good', reason: 'Liquidity injection' };
                    if (trend === 'rising') return { status: 'bad', reason: 'Liquidity drain' };
                    return { status: 'neutral', reason: 'Stable treasury' };

                default:
                    return { status: 'neutral', reason: 'Monitoring' };
            }
        }

        function createDualAxisChart(canvasId, data1, data2, label1, label2, color1, color2) {
            // Restore canvas element if it was replaced by loading/error state
            const container = document.getElementById(canvasId)?.parentElement;
            if (container && !document.getElementById(canvasId)) {
                container.innerHTML = `<canvas id="${canvasId}"></canvas>`;
            }
            
            const canvas = document.getElementById(canvasId);
            if (!canvas) {
                console.error(`Canvas ${canvasId} not found`);
                return;
            }
            
            const ctx = canvas.getContext('2d');
            const isDark = document.documentElement.classList.contains('dark');

            // Destroy existing chart if it exists
            if (chartInstances[canvasId]) {
                chartInstances[canvasId].destroy();
            }

            // Align data by date
            const alignedData = alignDataByDate(data1, data2);

            chartInstances[canvasId] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: alignedData.dates,
                    datasets: [{
                        label: label1,
                        data: alignedData.data1,
                        borderColor: color1,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1,
                        yAxisID: 'y'
                    }, {
                        label: label2,
                        data: alignedData.data2,
                        borderColor: color2,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1,
                        yAxisID: 'y1'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    scales: {
                        x: {
                            display: false,
                            grid: {
                                color: isDark ? '#374151' : '#f0f0f0'
                            },
                            ticks: {
                                color: isDark ? '#9ca3af' : '#6b7280'
                            }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            grid: {
                                color: isDark ? '#374151' : '#f0f0f0'
                            },
                            ticks: {
                                color: color1
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            grid: {
                                drawOnChartArea: false,
                            },
                            ticks: {
                                color: color2
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            labels: {
                                color: isDark ? '#9ca3af' : '#6b7280'
                            }
                        }
                    }
                }
            });

            // Add sentiment indicator for dual-axis charts
            addDualSentimentIndicator(canvasId, data1, data2, label1, label2);
        }

        function addDualSentimentIndicator(canvasId, data1, data2, label1, label2) {
            const canvas = document.getElementById(canvasId);
            if (!canvas || !data1 || !data2 || data1.length === 0 || data2.length === 0) return;

            const container = canvas.parentElement.parentElement;
            let sentimentEl = container.querySelector('.sentiment-indicator');
            
            if (!sentimentEl) {
                sentimentEl = document.createElement('div');
                sentimentEl.className = 'sentiment-indicator mt-3 p-2 rounded-lg';
                container.appendChild(sentimentEl);
            }

            // Analyze correlation and trends
            const sentiment = getDualChartSentiment(canvasId, data1, data2, label1, label2);
            
            const colors = {
                good: 'bg-green-100 dark:bg-green-900/20 border border-green-200 dark:border-green-800',
                neutral: 'bg-yellow-100 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800',
                bad: 'bg-red-100 dark:bg-red-900/20 border border-red-200 dark:border-red-800'
            };

            const textColors = {
                good: 'text-green-700 dark:text-green-300',
                neutral: 'text-yellow-700 dark:text-yellow-300',
                bad: 'text-red-700 dark:text-red-300'
            };

            const lights = {
                good: 'üü¢',
                neutral: 'üü°',
                bad: 'üî¥'
            };

            sentimentEl.className = `sentiment-indicator mt-3 flex items-center justify-center space-x-2 p-2 rounded-lg ${colors[sentiment.status]}`;
            sentimentEl.innerHTML = `
                <span class="text-lg">${lights[sentiment.status]}</span>
                <span class="font-medium ${textColors[sentiment.status]}">${sentiment.status.toUpperCase()}</span>
                <span class="text-sm ${textColors[sentiment.status]}">${sentiment.reason}</span>
            `;
        }

        function getDualChartSentiment(canvasId, data1, data2, label1, label2) {
            const latest1 = data1[data1.length - 1]?.value || 0;
            const latest2 = data2[data2.length - 1]?.value || 0;

            if (canvasId === 'm2BitcoinChart') {
                // M2 YoY vs Bitcoin YoY
                if (latest1 > 10 && latest2 > 50) return { status: 'good', reason: 'High M2 growth + Bitcoin gains' };
                if (latest1 < 5 && latest2 < 0) return { status: 'bad', reason: 'Low M2 growth + Bitcoin decline' };
                if (latest1 > 8) return { status: 'good', reason: 'Strong M2 growth supports crypto' };
                return { status: 'neutral', reason: 'Mixed signals' };
            }

            if (canvasId === 'dxyBitcoinChart') {
                // Inverted DXY vs Bitcoin 3M
                if (latest1 > 2 && latest2 > 10) return { status: 'good', reason: 'Dollar weakness + Bitcoin strength' };
                if (latest1 < -2 && latest2 < -10) return { status: 'bad', reason: 'Dollar strength + Bitcoin weakness' };
                if (latest1 > 0) return { status: 'good', reason: 'Dollar weakness favors crypto' };
                return { status: 'neutral', reason: 'Mixed currency signals' };
            }

            return { status: 'neutral', reason: 'Monitoring trends' };
        }

        function alignDataByDate(data1, data2) {
            const dates = [];
            const alignedData1 = [];
            const alignedData2 = [];
            
            // Create a map for faster lookup
            const data2Map = new Map(data2.map(d => [d.date, d.value]));
            
            data1.forEach(d1 => {
                if (data2Map.has(d1.date)) {
                    dates.push(d1.date);
                    alignedData1.push(d1.value);
                    alignedData2.push(data2Map.get(d1.date));
                }
            });
            
            return { dates, data1: alignedData1, data2: alignedData2 };
        }

        function recreateCharts() {
            // REAL DATA ONLY - NO MOCK DATA EVER
            
            // Single axis charts
            const singleCharts = [
                { id: 'bitcoinChart', data: chartData.bitcoin, label: 'Bitcoin Price', color: '#f7931a', name: 'Bitcoin' },
                { id: 'pmiChart', data: chartData.pmi, label: 'PMI', color: '#2563eb', name: 'PMI' },
                { id: 'nfciChart', data: chartData.nfci, label: 'NFCI', color: '#16a34a', name: 'NFCI' },
                { id: 'm2Chart', data: chartData.m2, label: 'M2', color: '#f59e0b', name: 'M2' },
                { id: 'tgaChart', data: chartData.tga, label: 'TGA', color: '#ef4444', name: 'TGA' }
            ];

            singleCharts.forEach(chart => {
                if (chart.data && chart.data.length > 0) {
                    const slicedData = chart.data.slice(-settings.dataPoints);
                    createChart(chart.id, slicedData, chart.label, chart.color);
                } else {
                    showDataError(chart.id, `${chart.name} data not available - API failed`);
                }
            });

            // Dual axis charts - REAL DATA ONLY
            if (chartData.m2 && chartData.bitcoin && chartData.m2.length > 12 && chartData.bitcoin.length > 12) {
                const m2YoY = calculateYoYChange(chartData.m2.slice(-settings.dataPoints - 12));
                const bitcoinYoY = calculateYoYChange(chartData.bitcoin.slice(-settings.dataPoints - 12));
                if (m2YoY.length > 0 && bitcoinYoY.length > 0) {
                    createDualAxisChart('m2BitcoinChart', m2YoY, bitcoinYoY, 'Global M2 YoY%', 'Bitcoin YoY%', '#2563eb', '#f59e0b');
                } else {
                    showDataError('m2BitcoinChart', 'Insufficient real data for YoY calculations');
                }
            } else {
                showDataError('m2BitcoinChart', 'M2 or Bitcoin real data not available');
            }

            if (chartData.dxy && chartData.bitcoin && chartData.dxy.length > 6 && chartData.bitcoin.length > 3) {
                const dxy3M = calculate3MChange(chartData.dxy.slice(-settings.dataPoints - 6));
                const invertedAdvancedDXY = invertAndAdvance(dxy3M, 3);
                const bitcoin3M = calculate3MChange(chartData.bitcoin.slice(-settings.dataPoints - 3));
                if (invertedAdvancedDXY.length > 0 && bitcoin3M.length > 0) {
                    createDualAxisChart('dxyBitcoinChart', invertedAdvancedDXY, bitcoin3M, 'Inverted DXY 3M% (Advanced)', 'Bitcoin 3M%', '#2563eb', '#f59e0b');
                } else {
                    showDataError('dxyBitcoinChart', 'Insufficient real data for 3M calculations');
                }
            } else {
                showDataError('dxyBitcoinChart', 'DXY or Bitcoin real data not available');
            }
        }

        async function loadData() {
            const statusEl = document.getElementById('status');
            const isDark = document.documentElement.classList.contains('dark');

            statusEl.classList.remove('hidden');
            statusEl.className = `mt-4 p-3 ${isDark ? 'bg-blue-900/20 border-blue-800 text-blue-300' : 'bg-blue-50 border-blue-200 text-blue-700'} border rounded-lg`;
            statusEl.innerHTML = `
                <div class="flex items-center space-x-2">
                    <div class="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
                    <p class="${isDark ? 'text-blue-300' : 'text-blue-700'}">Loading REAL data from APIs...</p>
                </div>
            `;

            // Show loading animation for all charts
            const chartIds = ['bitcoinChart', 'm2BitcoinChart', 'dxyBitcoinChart', 'pmiChart', 'nfciChart', 'm2Chart', 'tgaChart'];
            chartIds.forEach(chartId => {
                showChartLoading(chartId);
                retryCount[chartId] = 0; // Reset retry counts
            });

            const dataResults = {};
            const errors = [];
            let realDataCount = 0;

            try {
                console.log('Starting data fetch from real APIs...');

                // Fetch Bitcoin data first (most reliable) with retry logic
                try {
                    statusEl.innerHTML = `<p class="${isDark ? 'text-blue-300' : 'text-blue-700'}">Fetching Bitcoin price data...</p>`;
                    dataResults.bitcoin = await loadDataWithRetry('bitcoinChart', fetchBitcoinPrice);
                    realDataCount++;
                    console.log('‚úÖ Bitcoin data loaded successfully');
                } catch (error) {
                    errors.push(`Bitcoin: ${error.message}`);
                    console.error('‚ùå Bitcoin data failed after retries:', error);
                }

                // Fetch FRED data series with timeout and retry
                const fredSeries = [
                    { key: 'm2', id: 'M2SL', name: 'M2 Money Supply' },
                    { key: 'dxy', id: 'DEXUSEU', name: 'Dollar Index' },
                    { key: 'pmi', id: 'INDPRO', name: 'Industrial Production' }, // Industrial Production Index
                    { key: 'nfci', id: 'NFCI', name: 'Financial Conditions' },
                    { key: 'tga', id: 'WTREGEN', name: 'Treasury Account' }
                ];

                // Fetch FRED data with retry logic
                const fredPromises = fredSeries.map(async (series) => {
                    const chartIdMap = {
                        'm2': 'm2Chart',
                        'dxy': 'dxyBitcoinChart', 
                        'pmi': 'pmiChart',
                        'nfci': 'nfciChart',
                        'tga': 'tgaChart'
                    };
                    
                    const chartId = chartIdMap[series.key];
                    
                    try {
                        statusEl.innerHTML = `<p class="${isDark ? 'text-blue-300' : 'text-blue-700'}">Fetching ${series.name}...</p>`;
                        
                        const data = await loadDataWithRetry(chartId, () => {
                            const timeoutPromise = new Promise((_, reject) => 
                                setTimeout(() => reject(new Error('Timeout')), 10000)
                            );
                            const dataPromise = fetchFRED(series.id);
                            return Promise.race([dataPromise, timeoutPromise]);
                        });
                        
                        console.log(`‚úÖ ${series.name} data loaded successfully`);
                        return { key: series.key, data, success: true };
                    } catch (error) {
                        console.error(`‚ùå ${series.name} data failed after retries:`, error.message);
                        errors.push(`${series.name}: ${error.message}`);
                        return { key: series.key, data: null, success: false };
                    }
                });

                const fredResults = await Promise.all(fredPromises);
                
                fredResults.forEach(result => {
                    if (result.success && result.data) {
                        dataResults[result.key] = result.data;
                        realDataCount++;
                    }
                });

                // Store ONLY real data - NO MOCK DATA EVER
                chartData = dataResults;

                let chartsCreated = 0;

                // Create Bitcoin price chart - REAL DATA ONLY
                if (chartData.bitcoin && chartData.bitcoin.length > 0) {
                    createChart('bitcoinChart', chartData.bitcoin.slice(-settings.dataPoints), 'Bitcoin Price', '#f7931a');
                    chartsCreated++;
                } else {
                    showDataError('bitcoinChart', 'Bitcoin API failed - no real data available');
                }

                // Create M2 vs Bitcoin YoY chart - REAL DATA ONLY
                if (chartData.m2 && chartData.bitcoin && chartData.m2.length > 12 && chartData.bitcoin.length > 12) {
                    const m2YoY = calculateYoYChange(chartData.m2);
                    const bitcoinYoY = calculateYoYChange(chartData.bitcoin);
                    if (m2YoY.length > 0 && bitcoinYoY.length > 0) {
                        createDualAxisChart('m2BitcoinChart', m2YoY, bitcoinYoY, 'Global M2 YoY%', 'Bitcoin YoY%', '#2563eb', '#f59e0b');
                        chartsCreated++;
                    } else {
                        showDataError('m2BitcoinChart', 'Insufficient data for YoY calculations');
                    }
                } else {
                    showDataError('m2BitcoinChart', 'M2 or Bitcoin data unavailable');
                }

                // Create Inverted DXY vs Bitcoin 3M chart - REAL DATA ONLY
                if (chartData.dxy && chartData.bitcoin && chartData.dxy.length > 6 && chartData.bitcoin.length > 3) {
                    const dxy3M = calculate3MChange(chartData.dxy);
                    const invertedAdvancedDXY = invertAndAdvance(dxy3M, 3);
                    const bitcoin3M = calculate3MChange(chartData.bitcoin);
                    if (invertedAdvancedDXY.length > 0 && bitcoin3M.length > 0) {
                        createDualAxisChart('dxyBitcoinChart', invertedAdvancedDXY, bitcoin3M, 'Inverted DXY 3M% (Advanced)', 'Bitcoin 3M%', '#2563eb', '#f59e0b');
                        chartsCreated++;
                    } else {
                        showDataError('dxyBitcoinChart', 'Insufficient data for 3M calculations');
                    }
                } else {
                    showDataError('dxyBitcoinChart', 'DXY or Bitcoin data unavailable');
                }

                // Create economic indicator charts - REAL DATA ONLY
                const economicCharts = [
                    { key: 'pmi', id: 'pmiChart', label: 'PMI', color: '#2563eb', name: 'PMI data' },
                    { key: 'nfci', id: 'nfciChart', label: 'NFCI', color: '#16a34a', name: 'NFCI data' },
                    { key: 'm2', id: 'm2Chart', label: 'M2', color: '#f59e0b', name: 'M2 data' },
                    { key: 'tga', id: 'tgaChart', label: 'TGA', color: '#ef4444', name: 'TGA data' }
                ];

                economicCharts.forEach(chart => {
                    if (chartData[chart.key] && chartData[chart.key].length > 0) {
                        createChart(chart.id, chartData[chart.key].slice(-settings.dataPoints), chart.label, chart.color);
                        chartsCreated++;
                    } else {
                        showDataError(chart.id, `${chart.name} unavailable - API failed`);
                    }
                });

                // Update status based on REAL DATA ONLY
                if (realDataCount >= 5) {
                    statusEl.innerHTML = `<p class="${isDark ? 'text-green-300' : 'text-green-700'}">‚úÖ REAL DATA LOADED! (${realDataCount}/6 sources, ${chartsCreated} charts)</p>`;
                    statusEl.className = `mt-4 p-3 ${isDark ? 'bg-green-900/20 border-green-800' : 'bg-green-50 border-green-200'} border rounded-lg`;
                } else if (realDataCount > 0) {
                    statusEl.innerHTML = `<p class="${isDark ? 'text-yellow-300' : 'text-yellow-700'}">‚ö†Ô∏è PARTIAL REAL DATA (${realDataCount}/6 sources) - Some charts show errors</p>`;
                    statusEl.className = `mt-4 p-3 ${isDark ? 'bg-yellow-900/20 border-yellow-800' : 'bg-yellow-50 border-yellow-200'} border rounded-lg`;
                } else {
                    statusEl.innerHTML = `<p class="${isDark ? 'text-red-300' : 'text-red-700'}">‚ùå ALL APIs FAILED - NO REAL DATA AVAILABLE</p>`;
                    statusEl.className = `mt-4 p-3 ${isDark ? 'bg-red-900/20 border-red-800' : 'bg-red-50 border-red-200'} border rounded-lg`;
                }

                // Log errors for debugging
                if (errors.length > 0) {
                    console.log('API Errors:', errors);
                }

                setTimeout(() => {
                    statusEl.classList.add('hidden');
                }, 6000);

            } catch (error) {
                console.error('Critical error in loadData:', error);
                statusEl.innerHTML = `<p class="${isDark ? 'text-red-300' : 'text-red-700'}">‚ùå CRITICAL ERROR - NO REAL DATA AVAILABLE</p>`;
                statusEl.className = `mt-4 p-3 ${isDark ? 'bg-red-900/20 border-red-800' : 'bg-red-50 border-red-200'} border rounded-lg`;
                
                // Show error messages for all charts
                ['bitcoinChart', 'm2BitcoinChart', 'dxyBitcoinChart', 'pmiChart', 'nfciChart', 'm2Chart', 'tgaChart'].forEach(chartId => {
                    showDataError(chartId, 'Critical system error - all APIs failed');
                });
            }
        }

        // Test API connectivity
        async function testAPIs() {
            console.log('üîç Testing API connectivity...');
            
            // Test Bitcoin API
            try {
                const btcResponse = await fetch('https://api.coingecko.com/api/v3/ping');
                console.log('‚úÖ CoinGecko API is reachable');
            } catch (error) {
                console.log('‚ùå CoinGecko API unreachable:', error.message);
            }
            
            // Test FRED API through proxy
            try {
                const proxyResponse = await fetch('https://api.allorigins.win/get?url=' + encodeURIComponent('https://httpbin.org/json'));
                console.log('‚úÖ CORS proxy is working');
            } catch (error) {
                console.log('‚ùå CORS proxy failed:', error.message);
            }
        }

        // Initialize everything when page loads
        document.addEventListener('DOMContentLoaded', async () => {
            initDarkMode();
            initSettings();
            
            // Test APIs first
            await testAPIs();
            
            // Then load data
            loadData();
        });
    </script>
</body>

</html>