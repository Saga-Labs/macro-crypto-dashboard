<!DOCTYPE html>
<html lang="en" class="light">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Macro Dashboard</title>

    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="favicon.svg">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://saga-labs.github.io/macro-crypto-dashboard/">
    <meta property="og:title" content="Crypto Macro Dashboard">
    <meta property="og:description"
        content="Professional trading dashboard combining Bitcoin price action with key macroeconomic indicators for informed crypto investment decisions.">
    <meta property="og:image" content="https://saga-labs.github.io/macro-crypto-dashboard/images/macro-dashboard.png">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://saga-labs.github.io/macro-crypto-dashboard/">
    <meta property="twitter:title" content="Crypto Macro Dashboard">
    <meta property="twitter:description"
        content="Professional trading dashboard combining Bitcoin price action with key macroeconomic indicators for informed crypto investment decisions.">
    <meta property="twitter:image"
        content="https://saga-labs.github.io/macro-crypto-dashboard/images/macro-dashboard.png">

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #ffffff;
            color: #333333;
            min-height: 100vh;
            transition: all 0.3s ease;
        }

        body.dark {
            background: #1a1a1a;
            color: #ffffff;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .glass-card {
            background: #ffffff;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #e5e7eb;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .glass-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        body.dark .glass-card {
            background: #2d2d2d;
            border-color: #404040;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #1f2937;
        }

        body.dark .header h1 {
            color: #ffffff;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            background: #ffffff;
            border: 2px solid #d1d5db;
            color: #374151;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn:hover {
            background: #f9fafb;
            border-color: #9ca3af;
            color: #374151;
        }

        .btn.active {
            background: #3b82f6;
            border-color: #3b82f6;
            color: #ffffff;
        }

        body.dark .btn {
            background: #374151;
            border-color: #6b7280;
            color: #ffffff;
        }

        body.dark .btn:hover {
            background: #4b5563;
            border-color: #9ca3af;
        }

        .settings-panel {
            background: #ffffff;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #e5e7eb;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        body.dark .settings-panel {
            background: #2d2d2d;
            border-color: #404040;
        }

        .settings-panel h3 {
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            opacity: 0.9;
        }

        .form-control {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            background: #ffffff;
            color: #374151;
        }

        .form-control option {
            background: #ffffff;
            color: #374151;
        }

        body.dark .form-control {
            background: #374151;
            border-color: #6b7280;
            color: #ffffff;
        }

        body.dark .form-control option {
            background: #374151;
            color: #ffffff;
        }

        .cache-status {
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            padding-top: 15px;
            margin-top: 15px;
        }

        .cache-status h4 {
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .cache-info {
            font-size: 0.9em;
            opacity: 0.8;
            margin-bottom: 10px;
        }

        .status-alert {
            background: #dbeafe;
            border: 1px solid #3b82f6;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            color: #1e40af;
        }

        .status-alert.success {
            background: #dcfce7;
            border-color: #22c55e;
            color: #166534;
        }

        .status-alert.warning {
            background: #fef3c7;
            border-color: #f59e0b;
            color: #92400e;
        }

        .status-alert.error {
            background: #fee2e2;
            border-color: #ef4444;
            color: #dc2626;
        }

        body.dark .status-alert {
            background: #1e3a8a;
            border-color: #3b82f6;
            color: #dbeafe;
        }

        body.dark .status-alert.success {
            background: #166534;
            border-color: #22c55e;
            color: #dcfce7;
        }

        body.dark .status-alert.warning {
            background: #92400e;
            border-color: #f59e0b;
            color: #fef3c7;
        }

        body.dark .status-alert.error {
            background: #dc2626;
            border-color: #ef4444;
            color: #fee2e2;
        }

        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #e5e7eb;
            border-top: 2px solid #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        body.dark .spinner {
            border-color: #6b7280;
            border-top-color: #60a5fa;
        }

        .sentiment-indicator {
            margin-top: 12px;
            padding: 10px 16px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            font-size: 14px;
            font-weight: 600;
            border: 2px solid;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .sentiment-indicator.good {
            background-color: #dcfce7;
            border-color: #16a34a;
            color: #15803d;
            box-shadow: 0 2px 8px rgba(34, 197, 94, 0.2);
        }

        .sentiment-indicator.bad {
            background-color: #fee2e2;
            border-color: #dc2626;
            color: #b91c1c;
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.2);
        }

        .sentiment-indicator.neutral {
            background-color: #fef3c7;
            border-color: #d97706;
            color: #a16207;
            box-shadow: 0 2px 8px rgba(245, 158, 11, 0.2);
        }

        body.dark .sentiment-indicator.good {
            background-color: #14532d;
            border-color: #16a34a;
            color: #bbf7d0;
            box-shadow: 0 2px 8px rgba(34, 197, 94, 0.3);
        }

        body.dark .sentiment-indicator.bad {
            background-color: #991b1b;
            border-color: #dc2626;
            color: #fecaca;
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3);
        }

        body.dark .sentiment-indicator.neutral {
            background-color: #78350f;
            border-color: #d97706;
            color: #fed7aa;
            box-shadow: 0 2px 8px rgba(245, 158, 11, 0.3);
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .charts-grid {
            display: grid;
            gap: 20px;
            margin-top: 20px;
        }

        .charts-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
        }

        .chart-card {
            background: #ffffff;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #e5e7eb;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .chart-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        body.dark .chart-card {
            background: #2d2d2d;
            border-color: #404040;
        }

        .chart-card.full-width {
            grid-column: 1 / -1;
        }

        .chart-title {
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 10px;
            opacity: 0.95;
        }

        .chart-container {
            height: 200px;
            margin-bottom: 10px;
            position: relative;
        }

        .chart-insight {
            font-size: 0.85em;
            opacity: 0.8;
            line-height: 1.4;
        }

        .chart-insight strong {
            opacity: 1;
            color: #ffc107;
        }

        .footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            opacity: 0.7;
            font-size: 0.9em;
        }

        .hidden {
            display: none !important;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            .header h1 {
                font-size: 2em;
            }

            .controls {
                justify-content: center;
            }

            .charts-row {
                grid-template-columns: 1fr;
            }

            .chart-card {
                min-width: unset;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <header class="header">
            <h1>üöÄ Crypto Macro Dashboard</h1>
            <p>Professional trading dashboard combining Bitcoin with key macroeconomic indicators</p>
        </header>

        <div class="controls">
            <a href="https://github.com/Saga-Labs/macro-crypto-dashboard" target="_blank" rel="noopener noreferrer"
                class="btn" title="View on GitHub">
                <svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24">
                    <path
                        d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z" />
                </svg>
                GitHub
            </a>
            <button id="settingsBtn" class="btn">
                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z">
                    </path>
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                </svg>
                Settings
            </button>
            <button id="darkModeToggle" class="btn">
                <svg id="sunIcon" width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z">
                    </path>
                </svg>
                <svg id="moonIcon" width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                    style="display: none;">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z">
                    </path>
                </svg>
                Theme
            </button>
        </div>

        <!-- Settings Panel -->
        <div id="settingsPanel" class="settings-panel hidden">
            <h3>‚öôÔ∏è Chart Settings</h3>
            <div class="settings-grid">
                <div class="form-group">
                    <label>Data Points</label>
                    <select id="dataPoints" class="form-control">
                        <option value="30">Last 30 points</option>
                        <option value="60">Last 60 points</option>
                        <option value="90" selected>Last 90 points (3 months)</option>
                        <option value="180">Last 180 points (6 months)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Chart Type</label>
                    <select id="chartType" class="form-control">
                        <option value="line" selected>Line Chart</option>
                        <option value="bar">Bar Chart</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Show Fill</label>
                    <select id="showFill" class="form-control">
                        <option value="false" selected>No Fill</option>
                        <option value="true">Fill Area</option>
                    </select>
                </div>
            </div>

            <!-- Cache Status -->
            <div class="cache-status">
                <h4>üì¶ Data Cache Status</h4>
                <div id="cacheStatus" class="cache-info">
                    Loading cache status...
                </div>
                <div class="cache-info">
                    Cached data is refreshed automatically every 12 hours to minimize API calls and improve loading
                    speed.
                </div>
            </div>

            <div class="controls">
                <button id="applySettings" class="btn">Apply Settings</button>
                <button id="refreshData" class="btn">üîÑ Refresh Data</button>
                <button id="clearCache" class="btn">üóëÔ∏è Clear Cache</button>
                <button id="forceRefresh" class="btn">‚ö° Force Refresh</button>
            </div>
        </div>

        <div id="status" class="status-alert hidden">
            <div class="spinner"></div>
            <p>Loading economic data...</p>
        </div>

        <div class="charts-grid">
            <!-- Row 1: Bitcoin Price + M2 vs Bitcoin YoY -->
            <div class="charts-row">
                <div class="chart-card">
                    <h2 class="chart-title">‚Çø Bitcoin Price (USD)</h2>
                    <div class="chart-container">
                        <canvas id="bitcoinChart"></canvas>
                    </div>
                    <div class="chart-insight">
                        <p><strong>Key insight:</strong> Bitcoin drives market sentiment and predicts altcoin trends
                            within 24-48 hours.</p>
                    </div>
                </div>

                <div class="chart-card">
                    <h2 class="chart-title">üìà M2 vs Bitcoin YoY</h2>
                    <div class="chart-container">
                        <canvas id="m2BitcoinChart"></canvas>
                    </div>
                    <div class="chart-insight">
                        <p><strong>Key insight:</strong> M2 growth >10% YoY often drives Bitcoin adoption as inflation
                            hedge.</p>
                    </div>
                </div>
            </div>

            <!-- DXY vs Bitcoin 3M (Full Width) -->
            <div class="chart-card full-width">
                <h2 class="chart-title">üíµ DXY vs Bitcoin 3M</h2>
                <div class="chart-container">
                    <canvas id="dxyBitcoinChart"></canvas>
                </div>
                <div class="chart-insight">
                    <p><strong>Key insight:</strong> Dollar weakness precedes Bitcoin rallies by ~3 months. Leading
                        indicator for timing.</p>
                </div>
            </div>

            <!-- Row 2: Industrial Production + Financial Conditions -->
            <div class="charts-row">
                <div class="chart-card">
                    <h2 class="chart-title">üè≠ Industrial Production vs Bitcoin</h2>
                    <div class="chart-container">
                        <canvas id="pmiChart"></canvas>
                    </div>
                    <div class="chart-insight">
                        <p><strong>Key insight:</strong> Rising production supports risk assets. Declining production
                            triggers rotation away from crypto.</p>
                    </div>
                </div>

                <div class="chart-card">
                    <h2 class="chart-title">üìä Financial Conditions vs Bitcoin</h2>
                    <div class="chart-container">
                        <canvas id="nfciChart"></canvas>
                    </div>
                    <div class="chart-insight">
                        <p><strong>Key insight:</strong> Loose conditions (NFCI < -0.5) fuel crypto bulls. Tight
                                conditions (>0.5) precede bears.</p>
                    </div>
                </div>
            </div>

            <!-- Row 3: M2 Money Supply + Treasury Account -->
            <div class="charts-row">
                <div class="chart-card">
                    <h2 class="chart-title">üí∞ M2 Money Supply vs Bitcoin</h2>
                    <div class="chart-container">
                        <canvas id="m2Chart"></canvas>
                    </div>
                    <div class="chart-insight">
                        <p><strong>Key insight:</strong> Rapid M2 growth drives crypto adoption. Contractions hurt
                            crypto as liquidity dries up.</p>
                    </div>
                </div>

                <div class="chart-card">
                    <h2 class="chart-title">üèõÔ∏è Treasury Account vs Bitcoin</h2>
                    <div class="chart-container">
                        <canvas id="tgaChart"></canvas>
                    </div>
                    <div class="chart-insight">
                        <p><strong>Key insight:</strong> TGA drawdowns inject liquidity, boosting crypto. Builds drain
                            liquidity, pressuring prices.</p>
                    </div>
                </div>
            </div>
        </div>

        <footer class="footer">
            <div>üöÄ Professional trading dashboard powered by live market data from CoinGecko, Binance & FRED APIs</div>
        </footer>
    </div>

    <script>
        const FRED_API_KEY = "beee1466f76464d05ca4d42d26e0302c";
        let chartInstances = {};
        let chartData = {};
        let retryCount = {}; // Track retry attempts per chart

        // Enhanced caching system
        const CACHE_DURATION = 12 * 60 * 60 * 1000; // 12 hours in milliseconds
        const CACHE_KEY_PREFIX = 'macro_dashboard_';

        let settings = {
            dataPoints: 90, // 3 months of data (approximately)
            chartType: 'line',
            showFill: false
        };

        // Caching functions
        function getCachedData(key) {
            try {
                const cached = localStorage.getItem(CACHE_KEY_PREFIX + key);
                if (!cached) return null;

                const { data, timestamp } = JSON.parse(cached);
                const now = Date.now();

                // Check if cache is still valid (within 12 hours)
                if (now - timestamp < CACHE_DURATION) {
                    console.log(`üì¶ Using cached data for ${key} (${Math.round((now - timestamp) / (60 * 60 * 1000))}h old)`);
                    return data;
                }

                // Cache expired, remove it
                localStorage.removeItem(CACHE_KEY_PREFIX + key);
                console.log(`üóëÔ∏è Cache expired for ${key}, removed`);
                return null;
            } catch (error) {
                console.error(`‚ùå Error reading cache for ${key}:`, error);
                return null;
            }
        }

        function setCachedData(key, data) {
            try {
                const cacheEntry = {
                    data: data,
                    timestamp: Date.now()
                };
                localStorage.setItem(CACHE_KEY_PREFIX + key, JSON.stringify(cacheEntry));
                console.log(`üíæ Cached data for ${key}`);
            } catch (error) {
                console.error(`‚ùå Error caching data for ${key}:`, error);
                // If localStorage is full, clear old cache entries
                if (error.name === 'QuotaExceededError') {
                    clearOldCache();
                    // Try again
                    try {
                        localStorage.setItem(CACHE_KEY_PREFIX + key, JSON.stringify(cacheEntry));
                        console.log(`üíæ Cached data for ${key} after cleanup`);
                    } catch (retryError) {
                        console.error(`‚ùå Still failed to cache ${key}:`, retryError);
                    }
                }
            }
        }

        function clearOldCache() {
            console.log('üßπ Clearing old cache entries...');
            const keysToRemove = [];

            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith(CACHE_KEY_PREFIX)) {
                    try {
                        const cached = JSON.parse(localStorage.getItem(key));
                        const age = Date.now() - cached.timestamp;

                        // Remove entries older than 24 hours
                        if (age > 24 * 60 * 60 * 1000) {
                            keysToRemove.push(key);
                        }
                    } catch (error) {
                        // Invalid cache entry, remove it
                        keysToRemove.push(key);
                    }
                }
            }

            keysToRemove.forEach(key => {
                localStorage.removeItem(key);
                console.log(`üóëÔ∏è Removed old cache: ${key}`);
            });
        }

        function getCacheStatus() {
            const cacheInfo = {};
            const now = Date.now();

            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith(CACHE_KEY_PREFIX)) {
                    try {
                        const cached = JSON.parse(localStorage.getItem(key));
                        const ageHours = Math.round((now - cached.timestamp) / (60 * 60 * 1000));
                        const dataKey = key.replace(CACHE_KEY_PREFIX, '');
                        cacheInfo[dataKey] = {
                            age: ageHours,
                            valid: ageHours < 12,
                            size: cached.data?.length || 0
                        };
                    } catch (error) {
                        // Invalid cache entry
                    }
                }
            }

            return cacheInfo;
        }

        // Dark mode functionality
        function initDarkMode() {
            const darkModeToggle = document.getElementById('darkModeToggle');
            const body = document.body;
            const sunIcon = document.getElementById('sunIcon');
            const moonIcon = document.getElementById('moonIcon');

            // Check for saved theme preference or default to light
            const savedTheme = localStorage.getItem('theme') || 'light';
            const isDark = savedTheme === 'dark';

            body.classList.toggle('dark', isDark);
            sunIcon.style.display = isDark ? 'block' : 'none';
            moonIcon.style.display = isDark ? 'none' : 'block';

            darkModeToggle.addEventListener('click', () => {
                const isDark = body.classList.toggle('dark');
                localStorage.setItem('theme', isDark ? 'dark' : 'light');

                sunIcon.style.display = isDark ? 'block' : 'none';
                moonIcon.style.display = isDark ? 'none' : 'block';

                updateChartThemes();
            });
        }

        function updateTradingViewTheme() {
            const isDark = document.body.classList.contains('dark');
            const theme = isDark ? 'Dark' : 'Light';
            const toolbarbg = isDark ? '1e293b' : 'F1F3F6';

            // Update TradingView iframes
            const iframes = document.querySelectorAll('iframe');
            iframes.forEach(iframe => {
                const src = iframe.src;
                const newSrc = src.replace(/theme=(Light|Dark)/, `theme=${theme}`)
                    .replace(/toolbarbg=[A-Fa-f0-9]{6}/, `toolbarbg=${toolbarbg}`);
                if (newSrc !== src) {
                    iframe.src = newSrc;
                }
            });
        }

        function updateChartThemes() {
            const isDark = document.body.classList.contains('dark');
            Object.keys(chartInstances).forEach(chartId => {
                if (chartInstances[chartId]) {
                    chartInstances[chartId].options.scales.x.grid = {
                        color: isDark ? 'rgba(255,255,255,0.1)' : 'rgba(255,255,255,0.2)'
                    };
                    chartInstances[chartId].options.scales.y.grid = {
                        color: isDark ? 'rgba(255,255,255,0.1)' : 'rgba(255,255,255,0.2)'
                    };
                    chartInstances[chartId].options.scales.x.ticks = {
                        color: isDark ? 'rgba(255,255,255,0.8)' : 'rgba(255,255,255,0.9)'
                    };
                    chartInstances[chartId].options.scales.y.ticks = {
                        color: isDark ? 'rgba(255,255,255,0.8)' : 'rgba(255,255,255,0.9)'
                    };
                    chartInstances[chartId].update();
                }
            });
        }

        // Settings functionality
        function initSettings() {
            const settingsBtn = document.getElementById('settingsBtn');
            const settingsPanel = document.getElementById('settingsPanel');
            const applySettings = document.getElementById('applySettings');
            const refreshData = document.getElementById('refreshData');
            const clearCache = document.getElementById('clearCache');
            const forceRefresh = document.getElementById('forceRefresh');

            settingsBtn.addEventListener('click', () => {
                settingsPanel.classList.toggle('hidden');
                updateCacheStatus(); // Update cache status when panel opens
            });

            applySettings.addEventListener('click', () => {
                settings.dataPoints = parseInt(document.getElementById('dataPoints').value);
                settings.chartType = document.getElementById('chartType').value;
                settings.showFill = document.getElementById('showFill').value === 'true';

                // Recreate charts with new settings
                recreateCharts();
                settingsPanel.classList.add('hidden');
            });

            refreshData.addEventListener('click', () => {
                loadData();
                settingsPanel.classList.add('hidden');
            });

            clearCache.addEventListener('click', () => {
                // Clear all cached data
                for (let i = localStorage.length - 1; i >= 0; i--) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith(CACHE_KEY_PREFIX)) {
                        localStorage.removeItem(key);
                    }
                }
                console.log('üóëÔ∏è All cache cleared');
                updateCacheStatus();

                // Show confirmation
                const statusEl = document.getElementById('status');
                statusEl.innerHTML = '<p>üóëÔ∏è Cache cleared! Next data load will fetch fresh data.</p>';
                statusEl.className = 'status-alert warning';
                statusEl.classList.remove('hidden');
                setTimeout(() => statusEl.classList.add('hidden'), 3000);
            });

            forceRefresh.addEventListener('click', () => {
                // Clear cache and immediately reload data
                for (let i = localStorage.length - 1; i >= 0; i--) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith(CACHE_KEY_PREFIX)) {
                        localStorage.removeItem(key);
                    }
                }
                console.log('üîÑ Force refresh: cache cleared, loading fresh data');
                loadData();
                settingsPanel.classList.add('hidden');
            });
        }

        function updateCacheStatus() {
            const cacheInfo = getCacheStatus();
            const statusEl = document.getElementById('cacheStatus');

            if (Object.keys(cacheInfo).length === 0) {
                statusEl.innerHTML = '‚ùå No cached data found';
                return;
            }

            let statusHTML = '';
            Object.entries(cacheInfo).forEach(([key, info]) => {
                const icon = info.valid ? '‚úÖ' : '‚è∞';
                const ageText = info.age === 0 ? 'Just cached' : `${info.age}h old`;
                const dataName = key.replace('fred_', '').replace('bitcoin_price', 'Bitcoin').toUpperCase();
                statusHTML += `<div>${icon} ${dataName}: ${ageText} (${info.size} points)</div>`;
            });

            statusEl.innerHTML = statusHTML;
        }

        async function fetchFRED(seriesId) {
            // Check persistent cache first (12 hour cache)
            const cacheKey = `fred_${seriesId}`;
            const cachedData = getCachedData(cacheKey);
            if (cachedData) {
                return cachedData;
            }

            console.log(`üîç Fetching FRED series: ${seriesId}`);

            // Fast approach - use only the most reliable proxy with minimal data
            const approaches = [
                // Primary: AllOrigins (fastest and most reliable) - minimal data for speed
                async () => {
                    const proxyUrl = 'https://api.allorigins.win/get?url=';
                    const fredUrl = `https://api.stlouisfed.org/fred/series/observations?series_id=${seriesId}&api_key=${FRED_API_KEY}&file_type=json&limit=90&sort_order=desc`;

                    const response = await fetch(proxyUrl + encodeURIComponent(fredUrl), {
                        method: 'GET',
                        headers: { 'Accept': 'application/json' }
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const proxyData = await response.json();
                    if (!proxyData.contents) {
                        throw new Error('No contents in proxy response');
                    }

                    const data = JSON.parse(proxyData.contents);
                    return data;
                },

                // Approach 3: Try without proxy (might work in some environments)
                async () => {
                    const fredUrl = `https://api.stlouisfed.org/fred/series/observations?series_id=${seriesId}&api_key=${FRED_API_KEY}&file_type=json&limit=300&sort_order=desc`;
                    console.log(`üì° Trying direct FRED API for ${seriesId}...`);

                    const response = await fetch(fredUrl, {
                        method: 'GET',
                        headers: { 'Accept': 'application/json' }
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();
                    console.log(`üìä Direct API response for ${seriesId}:`, data.observations?.length || 0, 'observations');
                    return data;
                }
            ];

            let lastError = null;

            for (let i = 0; i < approaches.length; i++) {
                try {
                    const data = await approaches[i]();

                    if (!data || !data.observations || !Array.isArray(data.observations)) {
                        throw new Error(`Invalid data structure: ${JSON.stringify(data).substring(0, 100)}...`);
                    }

                    console.log(`üìà Processing ${data.observations.length} observations for ${seriesId}`);

                    const validData = data.observations
                        .filter(o => {
                            const isValid = o.value !== "." && o.value !== null && o.value !== undefined && !isNaN(parseFloat(o.value));
                            if (!isValid) console.log(`‚ùå Invalid observation:`, o);
                            return isValid;
                        })
                        .reverse() // Chronological order
                        .slice(-Math.max(settings.dataPoints, 120))
                        .map(o => ({
                            date: o.date,
                            value: parseFloat(o.value)
                        }));

                    if (validData.length === 0) {
                        throw new Error(`No valid data points found in ${data.observations.length} observations`);
                    }

                    console.log(`‚úÖ Successfully processed ${seriesId}: ${validData.length} valid data points`);
                    console.log(`üìÖ Date range: ${validData[0].date} to ${validData[validData.length - 1].date}`);
                    console.log(`üìä Value range: ${Math.min(...validData.map(d => d.value)).toFixed(2)} to ${Math.max(...validData.map(d => d.value)).toFixed(2)}`);

                    // Cache the successful result persistently (12 hours)
                    setCachedData(cacheKey, validData);

                    return validData;

                } catch (error) {
                    lastError = error;
                    console.error(`‚ùå Approach ${i + 1} failed for ${seriesId}:`, error.message);

                    if (i < approaches.length - 1) {
                        console.log(`üîÑ Trying next approach for ${seriesId}...`);
                    }
                }
            }

            console.error(`üí• All approaches failed for ${seriesId}. Last error:`, lastError?.message);
            throw new Error(`All approaches failed for ${seriesId}: ${lastError?.message}`);
        }

        async function fetchBitcoinPrice() {
            // Check persistent cache first (12 hour cache for Bitcoin)
            const cacheKey = 'bitcoin_price';
            const cachedData = getCachedData(cacheKey);
            if (cachedData) {
                return cachedData;
            }

            const apis = [
                {
                    name: 'Binance',
                    fetch: async () => {
                        const response = await fetch('https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1d&limit=120');
                        const data = await response.json();
                        return data.map(item => ({
                            date: new Date(item[0]).toISOString().split('T')[0],
                            value: parseFloat(item[4]) // Close price
                        }));
                    }
                },
                {
                    name: 'CoinGecko',
                    fetch: async () => {
                        const response = await fetch('https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=usd&days=120&interval=daily');
                        const data = await response.json();
                        return data.prices.map(([timestamp, price]) => ({
                            date: new Date(timestamp).toISOString().split('T')[0],
                            value: price
                        }));
                    }
                }
            ];

            for (const api of apis) {
                try {
                    console.log(`Fetching Bitcoin from ${api.name}...`);
                    const data = await api.fetch();

                    if (!data || data.length === 0) {
                        throw new Error('No data received');
                    }

                    const sortedData = data
                        .sort((a, b) => new Date(a.date) - new Date(b.date))
                        .slice(-Math.max(settings.dataPoints, 120));

                    console.log(`‚úÖ Successfully fetched Bitcoin from ${api.name}: ${sortedData.length} data points`);

                    // Cache the successful result persistently (12 hours)
                    setCachedData(cacheKey, sortedData);

                    return sortedData;

                } catch (error) {
                    console.log(`‚ùå ${api.name} failed:`, error.message);
                }
            }

            throw new Error('All Bitcoin APIs failed');
        }

        function calculateYoYChange(data) {
            const result = [];
            for (let i = 12; i < data.length; i++) {
                const current = data[i].value;
                const yearAgo = data[i - 12].value;
                const yoyChange = ((current - yearAgo) / yearAgo) * 100;
                result.push({
                    date: data[i].date,
                    value: yoyChange
                });
            }
            return result;
        }

        function calculate3MChange(data) {
            const result = [];
            for (let i = 3; i < data.length; i++) {
                const current = data[i].value;
                const threeMonthsAgo = data[i - 3].value;
                const change = ((current - threeMonthsAgo) / threeMonthsAgo) * 100;
                result.push({
                    date: data[i].date,
                    value: change
                });
            }
            return result;
        }

        function invertAndAdvance(data, months = 3) {
            const result = [];
            for (let i = 0; i < data.length - months; i++) {
                result.push({
                    date: data[i + months].date,
                    value: -data[i].value // Invert the values
                });
            }
            return result;
        }

        // Loading animation for individual charts
        function showChartLoading(chartId) {
            const canvas = document.getElementById(chartId);
            if (!canvas) return;

            const container = canvas.parentElement;
            const isDark = document.documentElement.classList.contains('dark');

            container.innerHTML = `
                <div style="height: 100%; display: flex; align-items: center; justify-content: center; background: rgba(255,255,255,0.1); border-radius: 10px;">
                    <div style="text-align: center;">
                        <div class="spinner" style="margin: 0 auto 10px;"></div>
                        <div style="color: rgba(255,255,255,0.8); font-size: 14px;">Loading data...</div>
                    </div>
                </div>
            `;
        }

        function showDataError(chartId, errorMessage, retryCount = 0) {
            const canvas = document.getElementById(chartId);
            if (!canvas) return;

            const container = canvas.parentElement;
            const isDark = document.body.classList.contains('dark');

            // Only show error after 3 failed attempts
            if (retryCount < 3) {
                return;
            }

            // Replace canvas with error message
            container.innerHTML = `
                <div style="height: 100%; display: flex; align-items: center; justify-content: center; background: rgba(239, 68, 68, 0.2); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 10px;">
                    <div style="text-align: center; padding: 20px;">
                        <div style="color: #ef4444; font-size: 16px; font-weight: 600; margin-bottom: 8px;">‚ùå Data Unavailable</div>
                        <div style="color: rgba(239, 68, 68, 0.8); font-size: 14px; margin-bottom: 12px;">${errorMessage}</div>
                        <button onclick="retryChart('${chartId}')" class="btn" style="background: rgba(239, 68, 68, 0.3); border-color: rgba(239, 68, 68, 0.5);">
                            üîÑ Retry Chart
                        </button>
                    </div>
                </div>
            `;
        }

        // Add a global retry function
        window.retryData = function () {
            console.log('üîÑ Manual retry triggered');
            loadData();
        }

        // Retry individual chart
        window.retryChart = async function (chartId) {
            console.log(`üîÑ Retrying chart: ${chartId}`);
            showChartLoading(chartId);

            // Reset retry count for this chart
            retryCount[chartId] = 0;

            try {
                if (chartId === 'bitcoinChart') {
                    await loadBitcoinData();
                } else {
                    await loadEconomicData(chartId);
                }
            } catch (error) {
                console.error(`Failed to retry ${chartId}:`, error);
                showDataError(chartId, error.message, 3);
            }
        }

        // Load data for specific chart with retry logic
        async function loadDataWithRetry(chartId, dataLoader, maxRetries = 3) {
            if (!retryCount[chartId]) retryCount[chartId] = 0;

            showChartLoading(chartId);

            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    retryCount[chartId] = attempt;
                    const data = await dataLoader();

                    if (data && data.length > 0) {
                        return data;
                    } else {
                        throw new Error('No data received');
                    }
                } catch (error) {
                    console.log(`‚ùå Attempt ${attempt + 1}/${maxRetries} failed for ${chartId}:`, error.message);

                    if (attempt < maxRetries - 1) {
                        // Reduced wait time for faster retries (500ms, 1s, 1.5s)
                        await new Promise(resolve => setTimeout(resolve, 500 * (attempt + 1)));
                    } else {
                        // Final attempt failed
                        retryCount[chartId] = maxRetries;
                        showDataError(chartId, error.message, maxRetries);
                        throw error;
                    }
                }
            }
        }

        // Add global test function
        window.testAPIs = testAPIs;

        function createChart(canvasId, data, label, color) {
            // Store reference to container for this canvas
            const chartContainers = {
                'bitcoinChart': '‚Çø Bitcoin Price (USD)',
                'm2BitcoinChart': 'üìà M2 vs Bitcoin YoY',
                'dxyBitcoinChart': 'üíµ DXY vs Bitcoin 3M',
                'pmiChart': 'üè≠ Industrial Production vs Bitcoin',
                'nfciChart': 'üìä Financial Conditions vs Bitcoin',
                'm2Chart': 'üí∞ M2 Money Supply vs Bitcoin',
                'tgaChart': 'üèõÔ∏è Treasury Account vs Bitcoin'
            };

            // Find the canvas or restore it if it was replaced by loading/error state
            let canvas = document.getElementById(canvasId);

            if (!canvas) {
                // Find the chart-card with the matching title and restore the canvas
                const chartCards = document.querySelectorAll('.chart-card');
                for (const card of chartCards) {
                    const title = card.querySelector('h2');
                    if (title && title.textContent.includes(chartContainers[canvasId])) {
                        const container = card.querySelector('.chart-container');
                        if (container) {
                            container.innerHTML = `<canvas id="${canvasId}"></canvas>`;
                            canvas = document.getElementById(canvasId);
                            console.log(`‚úÖ Restored canvas: ${canvasId}`);
                            break;
                        }
                    }
                }
            }

            if (!canvas) {
                console.error(`‚ùå Canvas ${canvasId} not found and could not be restored`);
                return;
            }

            const ctx = canvas.getContext('2d');
            const isDark = document.documentElement.classList.contains('dark');

            // Destroy existing chart if it exists
            if (chartInstances[canvasId]) {
                chartInstances[canvasId].destroy();
            }

            chartInstances[canvasId] = new Chart(ctx, {
                type: settings.chartType,
                data: {
                    labels: data.map(d => d.date),
                    datasets: [{
                        label: label,
                        data: data.map(d => d.value),
                        borderColor: color,
                        backgroundColor: settings.showFill ? color + '20' : 'transparent',
                        borderWidth: 2,
                        fill: settings.showFill,
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            display: false,
                            grid: {
                                color: isDark ? '#374151' : '#f0f0f0'
                            },
                            ticks: {
                                color: isDark ? '#9ca3af' : '#6b7280'
                            }
                        },
                        y: {
                            beginAtZero: false,
                            grid: {
                                color: isDark ? '#374151' : '#f0f0f0'
                            },
                            ticks: {
                                color: isDark ? '#9ca3af' : '#6b7280'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                }
            });

            // Add sentiment indicator
            addSentimentIndicator(canvasId, data, label);
        }

        function addSentimentIndicator(canvasId, data, label) {
            const canvas = document.getElementById(canvasId);
            if (!canvas || !data || data.length === 0) return;

            const container = canvas.parentElement.parentElement; // Get the section element
            let sentimentEl = container.querySelector('.sentiment-indicator');

            if (!sentimentEl) {
                sentimentEl = document.createElement('div');
                sentimentEl.className = 'sentiment-indicator';
                container.appendChild(sentimentEl);
            }

            const latestValue = data[data.length - 1].value;
            const sentiment = getCryptoSentiment(label, latestValue, data);

            const lights = {
                good: 'üü¢',
                neutral: 'üü°',
                bad: 'üî¥'
            };

            sentimentEl.className = `sentiment-indicator ${sentiment.status}`;
            sentimentEl.innerHTML = `
                <span>${lights[sentiment.status]}</span>
                <span>${sentiment.status.toUpperCase()}: ${sentiment.reason}</span>
            `;
        }

        function getCryptoSentiment(label, latestValue, data) {
            // Get trend (comparing last 10 vs previous 10 data points)
            const recent = data.slice(-10);
            const previous = data.slice(-20, -10);
            const recentAvg = recent.reduce((sum, d) => sum + d.value, 0) / recent.length;
            const previousAvg = previous.reduce((sum, d) => sum + d.value, 0) / previous.length;
            const trend = recentAvg > previousAvg ? 'rising' : 'falling';

            switch (label) {
                case 'Bitcoin Price':
                    if (trend === 'rising') return { status: 'good', reason: 'Price trending up' };
                    if (trend === 'falling') return { status: 'bad', reason: 'Price trending down' };
                    return { status: 'neutral', reason: 'Price stable' };

                case 'PMI':
                    if (latestValue > 52) return { status: 'good', reason: 'Strong expansion' };
                    if (latestValue < 48) return { status: 'bad', reason: 'Contraction risk' };
                    return { status: 'neutral', reason: 'Moderate conditions' };

                case 'NFCI':
                    if (latestValue < -0.5) return { status: 'good', reason: 'Loose conditions' };
                    if (latestValue > 0.5) return { status: 'bad', reason: 'Tight conditions' };
                    return { status: 'neutral', reason: 'Normal conditions' };

                case 'M2':
                    if (trend === 'rising') return { status: 'good', reason: 'Liquidity increasing' };
                    if (trend === 'falling') return { status: 'bad', reason: 'Liquidity decreasing' };
                    return { status: 'neutral', reason: 'Stable liquidity' };

                case 'TGA':
                    if (trend === 'falling') return { status: 'good', reason: 'Liquidity injection' };
                    if (trend === 'rising') return { status: 'bad', reason: 'Liquidity drain' };
                    return { status: 'neutral', reason: 'Stable treasury' };

                default:
                    return { status: 'neutral', reason: 'Monitoring' };
            }
        }

        function createDualAxisChart(canvasId, data1, data2, label1, label2, color1, color2) {
            // Store reference to container for this canvas
            const chartContainers = {
                'bitcoinChart': '‚Çø Bitcoin Price (USD)',
                'm2BitcoinChart': 'üìà M2 vs Bitcoin YoY',
                'dxyBitcoinChart': 'üíµ DXY vs Bitcoin 3M',
                'pmiChart': 'üè≠ Industrial Production vs Bitcoin',
                'nfciChart': 'üìä Financial Conditions vs Bitcoin',
                'm2Chart': 'üí∞ M2 Money Supply vs Bitcoin',
                'tgaChart': 'üèõÔ∏è Treasury Account vs Bitcoin'
            };

            // Find the canvas or restore it if it was replaced by loading/error state
            let canvas = document.getElementById(canvasId);

            if (!canvas) {
                // Find the chart-card with the matching title and restore the canvas
                const chartCards = document.querySelectorAll('.chart-card');
                for (const card of chartCards) {
                    const title = card.querySelector('h2');
                    if (title && title.textContent.includes(chartContainers[canvasId])) {
                        const container = card.querySelector('.chart-container');
                        if (container) {
                            container.innerHTML = `<canvas id="${canvasId}"></canvas>`;
                            canvas = document.getElementById(canvasId);
                            console.log(`‚úÖ Restored dual-axis canvas: ${canvasId}`);
                            break;
                        }
                    }
                }
            }

            if (!canvas) {
                console.error(`‚ùå Canvas ${canvasId} not found and could not be restored`);
                return;
            }

            const ctx = canvas.getContext('2d');
            const isDark = document.documentElement.classList.contains('dark');

            // Destroy existing chart if it exists
            if (chartInstances[canvasId]) {
                chartInstances[canvasId].destroy();
            }

            // Align data by date
            const alignedData = alignDataByDate(data1, data2);

            chartInstances[canvasId] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: alignedData.dates,
                    datasets: [{
                        label: label1,
                        data: alignedData.data1,
                        borderColor: color1,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1,
                        yAxisID: 'y'
                    }, {
                        label: label2,
                        data: alignedData.data2,
                        borderColor: color2,
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1,
                        yAxisID: 'y1'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    scales: {
                        x: {
                            display: false,
                            grid: {
                                color: isDark ? '#374151' : '#f0f0f0'
                            },
                            ticks: {
                                color: isDark ? '#9ca3af' : '#6b7280'
                            }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            grid: {
                                color: isDark ? '#374151' : '#f0f0f0'
                            },
                            ticks: {
                                color: color1
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            grid: {
                                drawOnChartArea: false,
                            },
                            ticks: {
                                color: color2
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            labels: {
                                color: isDark ? '#9ca3af' : '#6b7280'
                            }
                        }
                    }
                }
            });

            // Add sentiment indicator for dual-axis charts
            addDualSentimentIndicator(canvasId, data1, data2, label1, label2);
        }

        function addDualSentimentIndicator(canvasId, data1, data2, label1, label2) {
            const canvas = document.getElementById(canvasId);
            if (!canvas || !data1 || !data2 || data1.length === 0 || data2.length === 0) return;

            const container = canvas.parentElement.parentElement;
            let sentimentEl = container.querySelector('.sentiment-indicator');

            if (!sentimentEl) {
                sentimentEl = document.createElement('div');
                sentimentEl.className = 'sentiment-indicator mt-3 p-2 rounded-lg';
                container.appendChild(sentimentEl);
            }

            // Analyze correlation and trends
            const sentiment = getDualChartSentiment(canvasId, data1, data2, label1, label2);

            const colors = {
                good: 'bg-green-100 dark:bg-green-900/20 border border-green-200 dark:border-green-800',
                neutral: 'bg-yellow-100 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800',
                bad: 'bg-red-100 dark:bg-red-900/20 border border-red-200 dark:border-red-800'
            };

            const textColors = {
                good: 'text-green-700 dark:text-green-300',
                neutral: 'text-yellow-700 dark:text-yellow-300',
                bad: 'text-red-700 dark:text-red-300'
            };

            const lights = {
                good: 'üü¢',
                neutral: 'üü°',
                bad: 'üî¥'
            };

            sentimentEl.className = `sentiment-indicator mt-3 flex items-center justify-center space-x-2 p-2 rounded-lg ${colors[sentiment.status]}`;
            sentimentEl.innerHTML = `
                <span class="text-lg">${lights[sentiment.status]}</span>
                <span class="font-medium ${textColors[sentiment.status]}">${sentiment.status.toUpperCase()}</span>
                <span class="text-sm ${textColors[sentiment.status]}">${sentiment.reason}</span>
            `;
        }

        function getDualChartSentiment(canvasId, data1, data2, label1, label2) {
            const latest1 = data1[data1.length - 1]?.value || 0;
            const latest2 = data2[data2.length - 1]?.value || 0;

            if (canvasId === 'm2BitcoinChart') {
                // M2 YoY vs Bitcoin YoY
                if (latest1 > 10 && latest2 > 50) return { status: 'good', reason: 'High M2 growth + Bitcoin gains' };
                if (latest1 < 5 && latest2 < 0) return { status: 'bad', reason: 'Low M2 growth + Bitcoin decline' };
                if (latest1 > 8) return { status: 'good', reason: 'Strong M2 growth supports crypto' };
                return { status: 'neutral', reason: 'Mixed signals' };
            }

            if (canvasId === 'dxyBitcoinChart') {
                // Inverted DXY vs Bitcoin 3M
                if (latest1 > 2 && latest2 > 10) return { status: 'good', reason: 'Dollar weakness + Bitcoin strength' };
                if (latest1 < -2 && latest2 < -10) return { status: 'bad', reason: 'Dollar strength + Bitcoin weakness' };
                if (latest1 > 0) return { status: 'good', reason: 'Dollar weakness favors crypto' };
                return { status: 'neutral', reason: 'Mixed currency signals' };
            }

            if (canvasId === 'pmiChart') {
                // PMI vs Bitcoin
                const bitcoinTrend = latest2 > data2[data2.length - 5]?.value ? 'rising' : 'falling';
                if (latest1 > 52 && bitcoinTrend === 'rising') return { status: 'good', reason: 'Strong economy + Bitcoin gains' };
                if (latest1 < 48 && bitcoinTrend === 'falling') return { status: 'bad', reason: 'Weak economy + Bitcoin decline' };
                if (latest1 > 52) return { status: 'good', reason: 'Strong industrial expansion' };
                return { status: 'neutral', reason: 'Mixed economic signals' };
            }

            if (canvasId === 'nfciChart') {
                // NFCI vs Bitcoin
                const bitcoinTrend = latest2 > data2[data2.length - 5]?.value ? 'rising' : 'falling';
                if (latest1 < -0.5 && bitcoinTrend === 'rising') return { status: 'good', reason: 'Loose conditions + Bitcoin gains' };
                if (latest1 > 0.5 && bitcoinTrend === 'falling') return { status: 'bad', reason: 'Tight conditions + Bitcoin decline' };
                if (latest1 < -0.5) return { status: 'good', reason: 'Loose financial conditions' };
                return { status: 'neutral', reason: 'Mixed financial signals' };
            }

            if (canvasId === 'm2Chart') {
                // M2 vs Bitcoin
                const m2Trend = latest1 > data1[data1.length - 5]?.value ? 'rising' : 'falling';
                const bitcoinTrend = latest2 > data2[data2.length - 5]?.value ? 'rising' : 'falling';
                if (m2Trend === 'rising' && bitcoinTrend === 'rising') return { status: 'good', reason: 'Liquidity growth + Bitcoin gains' };
                if (m2Trend === 'falling' && bitcoinTrend === 'falling') return { status: 'bad', reason: 'Liquidity drain + Bitcoin decline' };
                if (m2Trend === 'rising') return { status: 'good', reason: 'Increasing liquidity' };
                return { status: 'neutral', reason: 'Mixed liquidity signals' };
            }

            if (canvasId === 'tgaChart') {
                // TGA vs Bitcoin
                const tgaTrend = latest1 < data1[data1.length - 5]?.value ? 'falling' : 'rising';
                const bitcoinTrend = latest2 > data2[data2.length - 5]?.value ? 'rising' : 'falling';
                if (tgaTrend === 'falling' && bitcoinTrend === 'rising') return { status: 'good', reason: 'Liquidity injection + Bitcoin gains' };
                if (tgaTrend === 'rising' && bitcoinTrend === 'falling') return { status: 'bad', reason: 'Liquidity drain + Bitcoin decline' };
                if (tgaTrend === 'falling') return { status: 'good', reason: 'Treasury liquidity injection' };
                return { status: 'neutral', reason: 'Mixed treasury signals' };
            }

            return { status: 'neutral', reason: 'Monitoring trends' };
        }

        function alignDataByDate(data1, data2) {
            const dates = [];
            const alignedData1 = [];
            const alignedData2 = [];

            // Create a map for faster lookup
            const data2Map = new Map(data2.map(d => [d.date, d.value]));

            data1.forEach(d1 => {
                if (data2Map.has(d1.date)) {
                    dates.push(d1.date);
                    alignedData1.push(d1.value);
                    alignedData2.push(data2Map.get(d1.date));
                }
            });

            return { dates, data1: alignedData1, data2: alignedData2 };
        }

        function recreateCharts() {
            // REAL DATA ONLY - NO MOCK DATA EVER

            // Single axis charts
            const singleCharts = [
                { id: 'bitcoinChart', data: chartData.bitcoin, label: 'Bitcoin Price', color: '#f7931a', name: 'Bitcoin' },
                { id: 'pmiChart', data: chartData.pmi, label: 'PMI', color: '#2563eb', name: 'PMI' },
                { id: 'nfciChart', data: chartData.nfci, label: 'NFCI', color: '#16a34a', name: 'NFCI' },
                { id: 'm2Chart', data: chartData.m2, label: 'M2', color: '#f59e0b', name: 'M2' },
                { id: 'tgaChart', data: chartData.tga, label: 'TGA', color: '#ef4444', name: 'TGA' }
            ];

            singleCharts.forEach(chart => {
                if (chart.data && chart.data.length > 0) {
                    const slicedData = chart.data.slice(-settings.dataPoints);
                    createChart(chart.id, slicedData, chart.label, chart.color);
                } else {
                    showDataError(chart.id, `${chart.name} data not available - API failed`);
                }
            });

            // Dual axis charts - REAL DATA ONLY
            if (chartData.m2 && chartData.bitcoin && chartData.m2.length > 12 && chartData.bitcoin.length > 12) {
                const m2YoY = calculateYoYChange(chartData.m2.slice(-settings.dataPoints - 12));
                const bitcoinYoY = calculateYoYChange(chartData.bitcoin.slice(-settings.dataPoints - 12));
                if (m2YoY.length > 0 && bitcoinYoY.length > 0) {
                    createDualAxisChart('m2BitcoinChart', m2YoY, bitcoinYoY, 'Global M2 YoY%', 'Bitcoin YoY%', '#2563eb', '#f59e0b');
                } else {
                    showDataError('m2BitcoinChart', 'Insufficient real data for YoY calculations');
                }
            } else {
                showDataError('m2BitcoinChart', 'M2 or Bitcoin real data not available');
            }

            if (chartData.dxy && chartData.bitcoin && chartData.dxy.length > 6 && chartData.bitcoin.length > 3) {
                const dxy3M = calculate3MChange(chartData.dxy.slice(-settings.dataPoints - 6));
                const invertedAdvancedDXY = invertAndAdvance(dxy3M, 3);
                const bitcoin3M = calculate3MChange(chartData.bitcoin.slice(-settings.dataPoints - 3));
                if (invertedAdvancedDXY.length > 0 && bitcoin3M.length > 0) {
                    createDualAxisChart('dxyBitcoinChart', invertedAdvancedDXY, bitcoin3M, 'Inverted DXY 3M% (Advanced)', 'Bitcoin 3M%', '#2563eb', '#f59e0b');
                } else {
                    showDataError('dxyBitcoinChart', 'Insufficient real data for 3M calculations');
                }
            } else {
                showDataError('dxyBitcoinChart', 'DXY or Bitcoin real data not available');
            }
        }

        async function loadData() {
            const statusEl = document.getElementById('status');
            const isDark = document.body.classList.contains('dark');

            // Check cache status
            const cacheInfo = getCacheStatus();
            const cachedCount = Object.values(cacheInfo).filter(info => info.valid).length;
            const totalSeries = 6; // Bitcoin + 5 FRED series

            statusEl.classList.remove('hidden');
            statusEl.className = 'status-alert';

            if (cachedCount > 0) {
                statusEl.innerHTML = `
                    <div class="spinner"></div>
                    <p>üì¶ Loading data (${cachedCount}/${totalSeries} from cache)...</p>
                `;
            } else {
                statusEl.innerHTML = `
                    <div class="spinner"></div>
                    <p>üåê Loading fresh data from APIs...</p>
                `;
            }

            // Show loading animation for all charts
            const chartIds = ['bitcoinChart', 'm2BitcoinChart', 'dxyBitcoinChart', 'pmiChart', 'nfciChart', 'm2Chart', 'tgaChart'];
            chartIds.forEach(chartId => {
                showChartLoading(chartId);
                retryCount[chartId] = 0; // Reset retry counts
            });

            const dataResults = {};
            const errors = [];
            let realDataCount = 0;

            try {
                console.log('Starting data fetch from real APIs...');

                // Fetch Bitcoin data with retry logic (parallel)
                const bitcoinPromise = loadDataWithRetry('bitcoinChart', fetchBitcoinPrice)
                    .then(data => {
                        dataResults.bitcoin = data;
                        realDataCount++;
                        console.log('‚úÖ Bitcoin data loaded successfully');
                        return { success: true };
                    })
                    .catch(error => {
                        errors.push(`Bitcoin: ${error.message}`);
                        console.error('‚ùå Bitcoin data failed after retries:', error);
                        return { success: false };
                    });

                // Fetch FRED data series with timeout and retry
                const fredSeries = [
                    { key: 'm2', id: 'M2SL', name: 'M2 Money Supply' },
                    { key: 'dxy', id: 'DEXUSEU', name: 'Dollar Index' },
                    { key: 'pmi', id: 'INDPRO', name: 'Industrial Production' }, // Industrial Production Index
                    { key: 'nfci', id: 'NFCI', name: 'Financial Conditions' },
                    { key: 'tga', id: 'WTREGEN', name: 'Treasury Account' }
                ];

                // Fetch FRED data with retry logic
                const fredPromises = fredSeries.map(async (series) => {
                    const chartIdMap = {
                        'm2': 'm2Chart',
                        'dxy': 'dxyBitcoinChart',
                        'pmi': 'pmiChart',
                        'nfci': 'nfciChart',
                        'tga': 'tgaChart'
                    };

                    const chartId = chartIdMap[series.key];

                    try {

                        const data = await loadDataWithRetry(chartId, () => {
                            const timeoutPromise = new Promise((_, reject) =>
                                setTimeout(() => reject(new Error('Timeout')), 3000)
                            );
                            const dataPromise = fetchFRED(series.id);
                            return Promise.race([dataPromise, timeoutPromise]);
                        });

                        console.log(`‚úÖ ${series.name} data loaded successfully`);
                        return { key: series.key, data, success: true };
                    } catch (error) {
                        console.error(`‚ùå ${series.name} data failed after retries:`, error.message);
                        errors.push(`${series.name}: ${error.message}`);
                        return { key: series.key, data: null, success: false };
                    }
                });

                // Wait for both Bitcoin and FRED data in parallel with progress updates
                let completedCount = 0;
                const totalCount = 6; // 1 Bitcoin + 5 FRED series

                // Update progress as each API completes
                const updateProgress = () => {
                    completedCount++;
                    const percentage = Math.round((completedCount / totalCount) * 100);
                    statusEl.innerHTML = `
                        <div class="spinner"></div>
                        <p>‚ö° Loading data... ${percentage}% (${completedCount}/${totalCount})</p>
                    `;
                };

                // Add progress tracking to promises
                const bitcoinWithProgress = bitcoinPromise.then(result => {
                    updateProgress();
                    return result;
                });

                const fredWithProgress = fredPromises.map(promise =>
                    promise.then(result => {
                        updateProgress();
                        return result;
                    })
                );

                const [bitcoinResult, fredResults] = await Promise.all([
                    bitcoinWithProgress,
                    Promise.all(fredWithProgress)
                ]);

                fredResults.forEach(result => {
                    if (result.success && result.data) {
                        dataResults[result.key] = result.data;
                        realDataCount++;
                    }
                });

                // Store ONLY real data - NO MOCK DATA EVER
                chartData = dataResults;

                let chartsCreated = 0;

                // Create Bitcoin price chart - REAL DATA ONLY
                if (chartData.bitcoin && chartData.bitcoin.length > 0) {
                    createChart('bitcoinChart', chartData.bitcoin.slice(-settings.dataPoints), 'Bitcoin Price', '#f7931a');
                    chartsCreated++;
                } else {
                    showDataError('bitcoinChart', 'Bitcoin API failed - no real data available');
                }

                // Create M2 vs Bitcoin YoY chart - REAL DATA ONLY
                if (chartData.m2 && chartData.bitcoin && chartData.m2.length > 12 && chartData.bitcoin.length > 12) {
                    const m2YoY = calculateYoYChange(chartData.m2);
                    const bitcoinYoY = calculateYoYChange(chartData.bitcoin);

                    // Debug: Log the data ranges to see if it's real
                    console.log('üìä M2 YoY Data Range:', {
                        count: m2YoY.length,
                        min: Math.min(...m2YoY.map(d => d.value)).toFixed(2),
                        max: Math.max(...m2YoY.map(d => d.value)).toFixed(2),
                        latest: m2YoY[m2YoY.length - 1]?.value.toFixed(2),
                        sample: m2YoY.slice(-5).map(d => `${d.date}: ${d.value.toFixed(1)}%`)
                    });

                    console.log('üìä Bitcoin YoY Data Range:', {
                        count: bitcoinYoY.length,
                        min: Math.min(...bitcoinYoY.map(d => d.value)).toFixed(2),
                        max: Math.max(...bitcoinYoY.map(d => d.value)).toFixed(2),
                        latest: bitcoinYoY[bitcoinYoY.length - 1]?.value.toFixed(2),
                        sample: bitcoinYoY.slice(-5).map(d => `${d.date}: ${d.value.toFixed(1)}%`)
                    });

                    if (m2YoY.length > 0 && bitcoinYoY.length > 0) {
                        createDualAxisChart('m2BitcoinChart', m2YoY, bitcoinYoY, 'M2 YoY%', 'Bitcoin YoY%', '#2563eb', '#f59e0b');
                        chartsCreated++;
                    } else {
                        showDataError('m2BitcoinChart', 'Insufficient data for YoY calculations');
                    }
                } else {
                    showDataError('m2BitcoinChart', 'M2 or Bitcoin data unavailable');
                }

                // Create Inverted DXY vs Bitcoin 3M chart - REAL DATA ONLY
                if (chartData.dxy && chartData.bitcoin && chartData.dxy.length > 6 && chartData.bitcoin.length > 3) {
                    const dxy3M = calculate3MChange(chartData.dxy);
                    const invertedAdvancedDXY = invertAndAdvance(dxy3M, 3);
                    const bitcoin3M = calculate3MChange(chartData.bitcoin);
                    if (invertedAdvancedDXY.length > 0 && bitcoin3M.length > 0) {
                        createDualAxisChart('dxyBitcoinChart', invertedAdvancedDXY, bitcoin3M, 'Inverted DXY 3M% (Advanced)', 'Bitcoin 3M%', '#2563eb', '#f59e0b');
                        chartsCreated++;
                    } else {
                        showDataError('dxyBitcoinChart', 'Insufficient data for 3M calculations');
                    }
                } else {
                    showDataError('dxyBitcoinChart', 'DXY or Bitcoin data unavailable');
                }

                // Create economic indicator charts with Bitcoin comparison - REAL DATA ONLY
                const economicCharts = [
                    { key: 'pmi', id: 'pmiChart', label: 'PMI', color: '#2563eb', name: 'PMI data' },
                    { key: 'nfci', id: 'nfciChart', label: 'NFCI', color: '#16a34a', name: 'NFCI data' },
                    { key: 'm2', id: 'm2Chart', label: 'M2', color: '#f59e0b', name: 'M2 data' },
                    { key: 'tga', id: 'tgaChart', label: 'TGA', color: '#ef4444', name: 'TGA data' }
                ];

                economicCharts.forEach(chart => {
                    if (chartData[chart.key] && chartData[chart.key].length > 0 && chartData.bitcoin && chartData.bitcoin.length > 0) {
                        // Create dual axis chart with Bitcoin comparison
                        const economicData = chartData[chart.key].slice(-settings.dataPoints);
                        const bitcoinData = chartData.bitcoin.slice(-settings.dataPoints);
                        createDualAxisChart(chart.id, economicData, bitcoinData, chart.label, 'Bitcoin Price', chart.color, '#f7931a');
                        chartsCreated++;
                    } else if (chartData[chart.key] && chartData[chart.key].length > 0) {
                        // Fallback to single chart if Bitcoin data unavailable
                        createChart(chart.id, chartData[chart.key].slice(-settings.dataPoints), chart.label, chart.color);
                        chartsCreated++;
                    } else {
                        showDataError(chart.id, `${chart.name} unavailable - API failed`);
                    }
                });

                // Wait a moment for charts to render, then update status
                setTimeout(() => {
                    // Update status based on REAL DATA AND CHARTS CREATED
                    if (chartsCreated >= 5) {
                        statusEl.innerHTML = `<p>‚úÖ CHARTS LOADED! (${chartsCreated} charts from ${realDataCount}/6 sources)</p>`;
                        statusEl.className = 'status-alert success';
                    } else if (chartsCreated > 0) {
                        statusEl.innerHTML = `<p>‚ö†Ô∏è PARTIAL CHARTS (${chartsCreated} charts from ${realDataCount}/6 sources)</p>`;
                        statusEl.className = 'status-alert warning';
                    } else {
                        statusEl.innerHTML = `<p>‚ùå NO CHARTS LOADED - API FAILURES</p>`;
                        statusEl.className = 'status-alert error';
                    }

                    // Hide status after showing success
                    setTimeout(() => {
                        statusEl.classList.add('hidden');
                    }, 4000);
                }, 500); // Wait 500ms for charts to render

                // Log errors for debugging
                if (errors.length > 0) {
                    console.log('API Errors:', errors);
                }

            } catch (error) {
                console.error('Critical error in loadData:', error);
                statusEl.innerHTML = `<p>‚ùå CRITICAL ERROR - NO REAL DATA AVAILABLE</p>`;
                statusEl.className = 'status-alert error';

                // Show error messages for all charts
                ['bitcoinChart', 'm2BitcoinChart', 'dxyBitcoinChart', 'pmiChart', 'nfciChart', 'm2Chart', 'tgaChart'].forEach(chartId => {
                    showDataError(chartId, 'Critical system error - all APIs failed');
                });
            }
        }

        // Test API connectivity
        async function testAPIs() {
            console.log('üîç Testing API connectivity...');

            // Test Bitcoin API
            try {
                const btcResponse = await fetch('https://api.coingecko.com/api/v3/ping');
                console.log('‚úÖ CoinGecko API is reachable');
            } catch (error) {
                console.log('‚ùå CoinGecko API unreachable:', error.message);
            }

            // Test FRED API through proxy
            try {
                const proxyResponse = await fetch('https://api.allorigins.win/get?url=' + encodeURIComponent('https://httpbin.org/json'));
                console.log('‚úÖ CORS proxy is working');
            } catch (error) {
                console.log('‚ùå CORS proxy failed:', error.message);
            }
        }

        // Initialize everything when page loads
        document.addEventListener('DOMContentLoaded', async () => {
            initDarkMode();
            initSettings();

            // Test APIs first
            await testAPIs();

            // Then load data
            loadData();
        });
    </script>
</body>

</html>